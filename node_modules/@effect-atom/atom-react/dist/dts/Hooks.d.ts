import * as Atom from "@effect-atom/atom/Atom";
import type * as AtomRef from "@effect-atom/atom/AtomRef";
import type * as Result from "@effect-atom/atom/Result";
import * as Exit from "effect/Exit";
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomInitialValues: (initialValues: Iterable<readonly [Atom.Atom<any>, any]>) => void;
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomValue: {
    <A>(atom: Atom.Atom<A>): A;
    <A, B>(atom: Atom.Atom<A>, f: (_: A) => B): B;
};
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomMount: <A>(atom: Atom.Atom<A>) => void;
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomSet: <R, W, Mode extends "value" | "promise" | "promiseExit" = never>(atom: Atom.Writable<R, W>, options?: {
    readonly mode?: ([R] extends [Result.Result<any, any>] ? Mode : "value") | undefined;
}) => "promise" extends Mode ? ((value: W) => Promise<Result.Result.Success<R>>) : "promiseExit" extends Mode ? ((value: W) => Promise<Exit.Exit<Result.Result.Success<R>, Result.Result.Failure<R>>>) : ((value: W | ((value: R) => W)) => void);
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomRefresh: <A>(atom: Atom.Atom<A>) => () => void;
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtom: <R, W, const Mode extends "value" | "promise" | "promiseExit" = never>(atom: Atom.Writable<R, W>, options?: {
    readonly mode?: ([R] extends [Result.Result<any, any>] ? Mode : "value") | undefined;
}) => readonly [value: R, write: "promise" extends Mode ? ((value: W) => Promise<Result.Result.Success<R>>) : "promiseExit" extends Mode ? ((value: W) => Promise<Exit.Exit<Result.Result.Success<R>, Result.Result.Failure<R>>>) : ((value: W | ((value: R) => W)) => void)];
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomSuspense: <A, E, const IncludeFailure extends boolean = false>(atom: Atom.Atom<Result.Result<A, E>>, options?: {
    readonly suspendOnWaiting?: boolean | undefined;
    readonly includeFailure?: IncludeFailure | undefined;
}) => Result.Success<A, E> | (IncludeFailure extends true ? Result.Failure<A, E> : never);
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomSubscribe: <A>(atom: Atom.Atom<A>, f: (_: A) => void, options?: {
    readonly immediate?: boolean;
}) => void;
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomRef: <A>(ref: AtomRef.ReadonlyRef<A>) => A;
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomRefProp: <A, K extends keyof A>(ref: AtomRef.AtomRef<A>, prop: K) => AtomRef.AtomRef<A[K]>;
/**
 * @since 1.0.0
 * @category hooks
 */
export declare const useAtomRefPropValue: <A, K extends keyof A>(ref: AtomRef.AtomRef<A>, prop: K) => A[K];
//# sourceMappingURL=Hooks.d.ts.map