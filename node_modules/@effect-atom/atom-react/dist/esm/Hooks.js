/**
 * @since 1.0.0
 */
"use client";

import * as Atom from "@effect-atom/atom/Atom";
import * as Registry from "@effect-atom/atom/Registry";
import { Effect } from "effect";
import * as Cause from "effect/Cause";
import * as Exit from "effect/Exit";
import { globalValue } from "effect/GlobalValue";
import * as React from "react";
import { RegistryContext } from "./RegistryContext.js";
const storeRegistry = /*#__PURE__*/globalValue("@effect-atom/atom-react/storeRegistry", () => new WeakMap());
function makeStore(registry, atom) {
  let stores = storeRegistry.get(registry);
  if (stores === undefined) {
    stores = new WeakMap();
    storeRegistry.set(registry, stores);
  }
  const store = stores.get(atom);
  if (store !== undefined) {
    return store;
  }
  const newStore = {
    subscribe(f) {
      return registry.subscribe(atom, f);
    },
    snapshot() {
      return registry.get(atom);
    },
    getServerSnapshot() {
      return Atom.getServerValue(atom, registry);
    }
  };
  stores.set(atom, newStore);
  return newStore;
}
function useStore(registry, atom) {
  const store = makeStore(registry, atom);
  return React.useSyncExternalStore(store.subscribe, store.snapshot, store.getServerSnapshot);
}
const initialValuesSet = /*#__PURE__*/globalValue("@effect-atom/atom-react/initialValuesSet", () => new WeakMap());
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomInitialValues = initialValues => {
  const registry = React.useContext(RegistryContext);
  let set = initialValuesSet.get(registry);
  if (set === undefined) {
    set = new WeakSet();
    initialValuesSet.set(registry, set);
  }
  for (const [atom, value] of initialValues) {
    if (!set.has(atom)) {
      set.add(atom);
      registry.ensureNode(atom).setValue(value);
    }
  }
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomValue = (atom, f) => {
  const registry = React.useContext(RegistryContext);
  if (f) {
    const atomB = React.useMemo(() => Atom.map(atom, f), [atom, f]);
    return useStore(registry, atomB);
  }
  return useStore(registry, atom);
};
function mountAtom(registry, atom) {
  React.useEffect(() => registry.mount(atom), [atom, registry]);
}
function setAtom(registry, atom, options) {
  if (options?.mode === "promise" || options?.mode === "promiseExit") {
    return React.useCallback(value => {
      registry.set(atom, value);
      const promise = Effect.runPromiseExit(Registry.getResult(registry, atom, {
        suspendOnWaiting: true
      }));
      return options.mode === "promise" ? promise.then(flattenExit) : promise;
    }, [registry, atom, options.mode]);
  }
  return React.useCallback(value => {
    registry.set(atom, typeof value === "function" ? value(registry.get(atom)) : value);
  }, [registry, atom]);
}
const flattenExit = exit => {
  if (Exit.isSuccess(exit)) return exit.value;
  throw Cause.squash(exit.cause);
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomMount = atom => {
  const registry = React.useContext(RegistryContext);
  mountAtom(registry, atom);
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomSet = (atom, options) => {
  const registry = React.useContext(RegistryContext);
  mountAtom(registry, atom);
  return setAtom(registry, atom, options);
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomRefresh = atom => {
  const registry = React.useContext(RegistryContext);
  mountAtom(registry, atom);
  return React.useCallback(() => {
    registry.refresh(atom);
  }, [registry, atom]);
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtom = (atom, options) => {
  const registry = React.useContext(RegistryContext);
  return [useStore(registry, atom), setAtom(registry, atom, options)];
};
const atomPromiseMap = /*#__PURE__*/globalValue("@effect-atom/atom-react/atomPromiseMap", () => ({
  suspendOnWaiting: new Map(),
  default: new Map()
}));
function atomToPromise(registry, atom, suspendOnWaiting) {
  const map = suspendOnWaiting ? atomPromiseMap.suspendOnWaiting : atomPromiseMap.default;
  let promise = map.get(atom);
  if (promise !== undefined) {
    return promise;
  }
  promise = new Promise(resolve => {
    const dispose = registry.subscribe(atom, result => {
      if (result._tag === "Initial" || suspendOnWaiting && result.waiting) {
        return;
      }
      setTimeout(dispose, 1000);
      resolve();
      map.delete(atom);
    });
  });
  map.set(atom, promise);
  return promise;
}
function atomResultOrSuspend(registry, atom, suspendOnWaiting) {
  const value = useStore(registry, atom);
  if (value._tag === "Initial" || suspendOnWaiting && value.waiting) {
    throw atomToPromise(registry, atom, suspendOnWaiting);
  }
  return value;
}
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomSuspense = (atom, options) => {
  const registry = React.useContext(RegistryContext);
  const result = atomResultOrSuspend(registry, atom, options?.suspendOnWaiting ?? false);
  if (result._tag === "Failure" && !options?.includeFailure) {
    throw Cause.squash(result.cause);
  }
  return result;
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomSubscribe = (atom, f, options) => {
  const registry = React.useContext(RegistryContext);
  React.useEffect(() => registry.subscribe(atom, f, options), [registry, atom, f, options?.immediate]);
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomRef = ref => {
  const [, setValue] = React.useState(ref.value);
  React.useEffect(() => ref.subscribe(setValue), [ref]);
  return ref.value;
};
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomRefProp = (ref, prop) => React.useMemo(() => ref.prop(prop), [ref, prop]);
/**
 * @since 1.0.0
 * @category hooks
 */
export const useAtomRefPropValue = (ref, prop) => useAtomRef(useAtomRefProp(ref, prop));
//# sourceMappingURL=Hooks.js.map