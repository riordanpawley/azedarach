"use strict";

/**
 * @since 1.0.0
 */
"use client";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAtomValue = exports.useAtomSuspense = exports.useAtomSubscribe = exports.useAtomSet = exports.useAtomRefresh = exports.useAtomRefPropValue = exports.useAtomRefProp = exports.useAtomRef = exports.useAtomMount = exports.useAtomInitialValues = exports.useAtom = void 0;
var Atom = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect-atom/atom/Atom"));
var Registry = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect-atom/atom/Registry"));
var _effect = /*#__PURE__*/require("effect");
var Cause = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Cause"));
var Exit = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Exit"));
var _GlobalValue = /*#__PURE__*/require("effect/GlobalValue");
var React = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("react"));
var _RegistryContext = /*#__PURE__*/require("./RegistryContext.js");
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
const storeRegistry = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect-atom/atom-react/storeRegistry", () => new WeakMap());
function makeStore(registry, atom) {
  let stores = storeRegistry.get(registry);
  if (stores === undefined) {
    stores = new WeakMap();
    storeRegistry.set(registry, stores);
  }
  const store = stores.get(atom);
  if (store !== undefined) {
    return store;
  }
  const newStore = {
    subscribe(f) {
      return registry.subscribe(atom, f);
    },
    snapshot() {
      return registry.get(atom);
    },
    getServerSnapshot() {
      return Atom.getServerValue(atom, registry);
    }
  };
  stores.set(atom, newStore);
  return newStore;
}
function useStore(registry, atom) {
  const store = makeStore(registry, atom);
  return React.useSyncExternalStore(store.subscribe, store.snapshot, store.getServerSnapshot);
}
const initialValuesSet = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect-atom/atom-react/initialValuesSet", () => new WeakMap());
/**
 * @since 1.0.0
 * @category hooks
 */
const useAtomInitialValues = initialValues => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  let set = initialValuesSet.get(registry);
  if (set === undefined) {
    set = new WeakSet();
    initialValuesSet.set(registry, set);
  }
  for (const [atom, value] of initialValues) {
    if (!set.has(atom)) {
      set.add(atom);
      registry.ensureNode(atom).setValue(value);
    }
  }
};
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomInitialValues = useAtomInitialValues;
const useAtomValue = (atom, f) => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  if (f) {
    const atomB = React.useMemo(() => Atom.map(atom, f), [atom, f]);
    return useStore(registry, atomB);
  }
  return useStore(registry, atom);
};
exports.useAtomValue = useAtomValue;
function mountAtom(registry, atom) {
  React.useEffect(() => registry.mount(atom), [atom, registry]);
}
function setAtom(registry, atom, options) {
  if (options?.mode === "promise" || options?.mode === "promiseExit") {
    return React.useCallback(value => {
      registry.set(atom, value);
      const promise = _effect.Effect.runPromiseExit(Registry.getResult(registry, atom, {
        suspendOnWaiting: true
      }));
      return options.mode === "promise" ? promise.then(flattenExit) : promise;
    }, [registry, atom, options.mode]);
  }
  return React.useCallback(value => {
    registry.set(atom, typeof value === "function" ? value(registry.get(atom)) : value);
  }, [registry, atom]);
}
const flattenExit = exit => {
  if (Exit.isSuccess(exit)) return exit.value;
  throw Cause.squash(exit.cause);
};
/**
 * @since 1.0.0
 * @category hooks
 */
const useAtomMount = atom => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  mountAtom(registry, atom);
};
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomMount = useAtomMount;
const useAtomSet = (atom, options) => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  mountAtom(registry, atom);
  return setAtom(registry, atom, options);
};
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomSet = useAtomSet;
const useAtomRefresh = atom => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  mountAtom(registry, atom);
  return React.useCallback(() => {
    registry.refresh(atom);
  }, [registry, atom]);
};
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomRefresh = useAtomRefresh;
const useAtom = (atom, options) => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  return [useStore(registry, atom), setAtom(registry, atom, options)];
};
exports.useAtom = useAtom;
const atomPromiseMap = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect-atom/atom-react/atomPromiseMap", () => ({
  suspendOnWaiting: new Map(),
  default: new Map()
}));
function atomToPromise(registry, atom, suspendOnWaiting) {
  const map = suspendOnWaiting ? atomPromiseMap.suspendOnWaiting : atomPromiseMap.default;
  let promise = map.get(atom);
  if (promise !== undefined) {
    return promise;
  }
  promise = new Promise(resolve => {
    const dispose = registry.subscribe(atom, result => {
      if (result._tag === "Initial" || suspendOnWaiting && result.waiting) {
        return;
      }
      setTimeout(dispose, 1000);
      resolve();
      map.delete(atom);
    });
  });
  map.set(atom, promise);
  return promise;
}
function atomResultOrSuspend(registry, atom, suspendOnWaiting) {
  const value = useStore(registry, atom);
  if (value._tag === "Initial" || suspendOnWaiting && value.waiting) {
    throw atomToPromise(registry, atom, suspendOnWaiting);
  }
  return value;
}
/**
 * @since 1.0.0
 * @category hooks
 */
const useAtomSuspense = (atom, options) => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  const result = atomResultOrSuspend(registry, atom, options?.suspendOnWaiting ?? false);
  if (result._tag === "Failure" && !options?.includeFailure) {
    throw Cause.squash(result.cause);
  }
  return result;
};
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomSuspense = useAtomSuspense;
const useAtomSubscribe = (atom, f, options) => {
  const registry = React.useContext(_RegistryContext.RegistryContext);
  React.useEffect(() => registry.subscribe(atom, f, options), [registry, atom, f, options?.immediate]);
};
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomSubscribe = useAtomSubscribe;
const useAtomRef = ref => {
  const [, setValue] = React.useState(ref.value);
  React.useEffect(() => ref.subscribe(setValue), [ref]);
  return ref.value;
};
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomRef = useAtomRef;
const useAtomRefProp = (ref, prop) => React.useMemo(() => ref.prop(prop), [ref, prop]);
/**
 * @since 1.0.0
 * @category hooks
 */
exports.useAtomRefProp = useAtomRefProp;
const useAtomRefPropValue = (ref, prop) => useAtomRef(useAtomRefProp(ref, prop));
exports.useAtomRefPropValue = useAtomRefPropValue;
//# sourceMappingURL=Hooks.js.map