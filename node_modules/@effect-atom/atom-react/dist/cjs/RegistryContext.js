"use strict";

/**
 * @since 1.0.0
 */
"use client";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegistryProvider = exports.RegistryContext = void 0;
exports.scheduleTask = scheduleTask;
var Registry = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect-atom/atom/Registry"));
var React = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("react"));
var Scheduler = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("scheduler"));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
/**
 * @since 1.0.0
 * @category context
 */
function scheduleTask(f) {
  Scheduler.unstable_scheduleCallback(Scheduler.unstable_LowPriority, f);
}
/**
 * @since 1.0.0
 * @category context
 */
const RegistryContext = exports.RegistryContext = /*#__PURE__*/React.createContext(/*#__PURE__*/Registry.make({
  scheduleTask,
  defaultIdleTTL: 400
}));
/**
 * @since 1.0.0
 * @category context
 */
const RegistryProvider = options => {
  const ref = React.useRef(null);
  if (ref.current === null) {
    ref.current = {
      registry: Registry.make({
        scheduleTask: options.scheduleTask ?? scheduleTask,
        initialValues: options.initialValues,
        timeoutResolution: options.timeoutResolution,
        defaultIdleTTL: options.defaultIdleTTL
      })
    };
  }
  React.useEffect(() => {
    if (ref.current?.timeout !== undefined) {
      clearTimeout(ref.current.timeout);
    }
    return () => {
      ref.current.timeout = setTimeout(() => {
        ref.current?.registry.dispose();
        ref.current = null;
      }, 500);
    };
  }, [ref]);
  return React.createElement(RegistryContext.Provider, {
    value: ref.current.registry
  }, options?.children);
};
exports.RegistryProvider = RegistryProvider;
//# sourceMappingURL=RegistryContext.js.map