/**
 * @since 1.0.0
 */
import * as Cause from "effect/Cause";
import * as Exit from "effect/Exit";
import type { LazyArg } from "effect/Function";
import * as Option from "effect/Option";
import { type Pipeable } from "effect/Pipeable";
import type { Predicate, Refinement } from "effect/Predicate";
import * as Schema_ from "effect/Schema";
import type * as Types from "effect/Types";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category models
 */
export type Result<A, E = never> = Initial<A, E> | Success<A, E> | Failure<A, E>;
/**
 * @since 1.0.0
 * @category Guards
 */
export declare const isResult: (u: unknown) => u is Result<unknown, unknown>;
/**
 * @since 1.0.0
 * @category models
 */
export declare namespace Result {
    /**
     * @since 1.0.0
     * @category models
     */
    interface Proto<A, E> extends Pipeable {
        readonly [TypeId]: {
            readonly E: (_: never) => E;
            readonly A: (_: never) => A;
        };
        readonly waiting: boolean;
    }
    /**
     * @since 1.0.0
     */
    type Success<R> = R extends Result<infer A, infer _> ? A : never;
    /**
     * @since 1.0.0
     */
    type Failure<R> = R extends Result<infer _, infer E> ? E : never;
}
/**
 * @since 1.0.0
 */
export type With<R extends Result<any, any>, A, E> = R extends Initial<infer _A, infer _E> ? Initial<A, E> : R extends Success<infer _A, infer _E> ? Success<A, E> : R extends Failure<infer _A, infer _E> ? Failure<A, E> : never;
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isWaiting: <A, E>(result: Result<A, E>) => boolean;
/**
 * @since 1.0.0
 * @category models
 */
export interface Initial<A, E = never> extends Result.Proto<A, E> {
    readonly _tag: "Initial";
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Success<A, E> | Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const fromExitWithPrevious: <A, E>(exit: Exit.Exit<A, E>, previous: Option.Option<Result<A, E>>) => Success<A, E> | Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const waitingFrom: <A, E>(previous: Option.Option<Result<A, E>>) => Result<A, E>;
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isInitial: <A, E>(result: Result<A, E>) => result is Initial<A, E>;
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isNotInitial: <A, E>(result: Result<A, E>) => result is Success<A, E> | Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const initial: <A = never, E = never>(waiting?: boolean) => Initial<A, E>;
/**
 * @since 1.0.0
 * @category models
 */
export interface Success<A, E = never> extends Result.Proto<A, E> {
    readonly _tag: "Success";
    readonly value: A;
    readonly timestamp: number;
}
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isSuccess: <A, E>(result: Result<A, E>) => result is Success<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const success: <A, E = never>(value: A, options?: {
    readonly waiting?: boolean | undefined;
    readonly timestamp?: number | undefined;
}) => Success<A, E>;
/**
 * @since 1.0.0
 * @category models
 */
export interface Failure<A, E = never> extends Result.Proto<A, E> {
    readonly _tag: "Failure";
    readonly cause: Cause.Cause<E>;
    readonly previousSuccess: Option.Option<Success<A, E>>;
}
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isFailure: <A, E>(result: Result<A, E>) => result is Failure<A, E>;
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isInterrupted: <A, E>(result: Result<A, E>) => result is Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const failure: <A, E = never>(cause: Cause.Cause<E>, options?: {
    readonly previousSuccess?: Option.Option<Success<A, E>> | undefined;
    readonly waiting?: boolean | undefined;
}) => Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const failureWithPrevious: <A, E>(cause: Cause.Cause<E>, options: {
    readonly previous: Option.Option<Result<A, E>>;
    readonly waiting?: boolean | undefined;
}) => Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const fail: <E, A = never>(error: E, options?: {
    readonly previousSuccess?: Option.Option<Success<A, E>> | undefined;
    readonly waiting?: boolean | undefined;
}) => Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const failWithPrevious: <A, E>(error: E, options: {
    readonly previous: Option.Option<Result<A, E>>;
    readonly waiting?: boolean | undefined;
}) => Failure<A, E>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const waiting: <R extends Result<any, any>>(self: R, options?: {
    readonly touch?: boolean | undefined;
}) => R;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const touch: <A extends Result<any, any>>(result: A) => A;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const replacePrevious: <R extends Result<any, any>, XE, A>(self: R, previous: Option.Option<Result<A, XE>>) => With<R, A, Result.Failure<R>>;
/**
 * @since 1.0.0
 * @category accessors
 */
export declare const value: <A, E>(self: Result<A, E>) => Option.Option<A>;
/**
 * @since 1.0.0
 * @category accessors
 */
export declare const getOrElse: {
    <B>(orElse: LazyArg<B>): <A, E>(self: Result<A, E>) => A | B;
    <A, E, B>(self: Result<A, E>, orElse: LazyArg<B>): A | B;
};
/**
 * @since 1.0.0
 * @category accessors
 */
export declare const getOrThrow: <A, E>(self: Result<A, E>) => A;
/**
 * @since 1.0.0
 * @category accessors
 */
export declare const cause: <A, E>(self: Result<A, E>) => Option.Option<Cause.Cause<E>>;
/**
 * @since 1.0.0
 * @category accessors
 */
export declare const error: <A, E>(self: Result<A, E>) => Option.Option<E>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const toExit: <A, E>(self: Result<A, E>) => Exit.Exit<A, E | Cause.NoSuchElementException>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const map: {
    <A, B>(f: (a: A) => B): <E>(self: Result<A, E>) => Result<B, E>;
    <E, A, B>(self: Result<A, E>, f: (a: A) => B): Result<B, E>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const flatMap: {
    <A, E, B, E2>(f: (a: A, prev: Success<A, E>) => Result<A, E2>): (self: Result<A, E>) => Result<B, E | E2>;
    <E, A, B, E2>(self: Result<A, E>, f: (a: A, prev: Success<A, E>) => Result<B, E2>): Result<B, E | E2>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const match: {
    <A, E, X, Y, Z>(options: {
        readonly onInitial: (_: Initial<A, E>) => X;
        readonly onFailure: (_: Failure<A, E>) => Y;
        readonly onSuccess: (_: Success<A, E>) => Z;
    }): (self: Result<A, E>) => X | Y | Z;
    <A, E, X, Y, Z>(self: Result<A, E>, options: {
        readonly onInitial: (_: Initial<A, E>) => X;
        readonly onFailure: (_: Failure<A, E>) => Y;
        readonly onSuccess: (_: Success<A, E>) => Z;
    }): X | Y | Z;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const matchWithError: {
    <A, E, W, X, Y, Z>(options: {
        readonly onInitial: (_: Initial<A, E>) => W;
        readonly onError: (error: E, _: Failure<A, E>) => X;
        readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y;
        readonly onSuccess: (_: Success<A, E>) => Z;
    }): (self: Result<A, E>) => W | X | Y | Z;
    <A, E, W, X, Y, Z>(self: Result<A, E>, options: {
        readonly onInitial: (_: Initial<A, E>) => W;
        readonly onError: (error: E, _: Failure<A, E>) => X;
        readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y;
        readonly onSuccess: (_: Success<A, E>) => Z;
    }): W | X | Y | Z;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const matchWithWaiting: {
    <A, E, W, X, Y, Z>(options: {
        readonly onWaiting: (_: Result<A, E>) => W;
        readonly onError: (error: E, _: Failure<A, E>) => X;
        readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y;
        readonly onSuccess: (_: Success<A, E>) => Z;
    }): (self: Result<A, E>) => W | X | Y | Z;
    <A, E, W, X, Y, Z>(self: Result<A, E>, options: {
        readonly onWaiting: (_: Result<A, E>) => W;
        readonly onError: (error: E, _: Failure<A, E>) => X;
        readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y;
        readonly onSuccess: (_: Success<A, E>) => Z;
    }): W | X | Y | Z;
};
/**
 * Combines multiple results into a single result. Also works with non-result
 * values.
 *
 * @since 1.0.0
 * @category combinators
 */
export declare const all: <const Arg extends Iterable<any> | Record<string, any>>(results: Arg) => Result<[Arg] extends [ReadonlyArray<any>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Result<infer _A, infer _E>] ? _A : Arg[K]; } : [Arg] extends [Iterable<infer _A>] ? _A extends Result<infer _AA, infer _E_1> ? _AA : _A : [Arg] extends [Record<string, any>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Result<infer _A, infer _E_2>] ? _A : Arg[K]; } : never, [Arg] extends [ReadonlyArray<any>] ? Result.Failure<Arg[number]> : [Arg] extends [Iterable<infer _A>] ? Result.Failure<_A> : [Arg] extends [Record<string, any>] ? Result.Failure<Arg[keyof Arg]> : never>;
/**
 * @since 1.0.0
 * @category Builder
 */
export declare const builder: <A extends Result<any, any>>(self: A) => Builder<never, A extends Success<infer _A, infer _E> ? _A : never, A extends Failure<infer _A, infer _E_1> ? _E_1 : never, A extends Initial<infer _A, infer _E_2> ? true : never>;
/**
 * @since 1.0.0
 * @category Builder
 */
export type Builder<Out, A, E, I> = Pipeable & {
    onWaiting<B>(f: (result: Result<A, E>) => B): Builder<Out | B, A, E, I>;
    onDefect<B>(f: (defect: unknown, result: Failure<A, E>) => B): Builder<Out | B, A, E, I>;
    orElse<B>(orElse: LazyArg<B>): Out | B;
    orNull(): Out | null;
    render(): [A | I] extends [never] ? Out : Out | null;
} & ([I] extends [never] ? {} : {
    onInitial<B>(f: (result: Initial<A, E>) => B): Builder<Out | B, A, E, never>;
    onInitialOrWaiting<B>(f: (result: Result<A, E>) => B): Builder<Out | B, A, E, never>;
}) & ([A] extends [never] ? {} : {
    onSuccess<B>(f: (value: A, result: Success<A, E>) => B): Builder<Out | B, never, E, I>;
}) & ([E] extends [never] ? {} : {
    onFailure<B>(f: (cause: Cause.Cause<E>, result: Failure<A, E>) => B): Builder<Out | B, A, never, I>;
    onError<B>(f: (error: E, result: Failure<A, E>) => B): Builder<Out | B, A, never, I>;
    onErrorIf<B extends E, C>(refinement: Refinement<E, B>, f: (error: B, result: Failure<A, E>) => C): Builder<Out | C, A, Types.EqualsWith<E, B, E, Exclude<E, B>>, I>;
    onErrorIf<C>(predicate: Predicate<E>, f: (error: E, result: Failure<A, E>) => C): Builder<Out | C, A, E, I>;
    onErrorTag<const Tags extends ReadonlyArray<Types.Tags<E>>, B>(tags: Tags, f: (error: Types.ExtractTag<E, Tags[number]>, result: Failure<A, E>) => B): Builder<Out | B, A, Types.ExcludeTag<E, Tags[number]>, I>;
    onErrorTag<const Tag extends Types.Tags<E>, B>(tag: Tag, f: (error: Types.ExtractTag<E, Tag>, result: Failure<A, E>) => B): Builder<Out | B, A, Types.ExcludeTag<E, Tag>, I>;
});
/**
 * @since 1.0.0
 * @category Schemas
 */
export type PartialEncoded<A, E> = {
    readonly _tag: "Initial";
    readonly waiting: boolean;
} | {
    readonly _tag: "Success";
    readonly waiting: boolean;
    readonly timestamp: number;
    readonly value: A;
} | {
    readonly _tag: "Failure";
    readonly waiting: boolean;
    readonly previousValue: Option.Option<A>;
    readonly cause: Cause.Cause<E>;
};
/**
 * @since 1.0.0
 * @category Schemas
 */
export type Encoded<A, E> = {
    readonly _tag: "Initial";
    readonly waiting: boolean;
} | {
    readonly _tag: "Success";
    readonly waiting: boolean;
    readonly timestamp: number;
    readonly value: A;
} | {
    readonly _tag: "Failure";
    readonly waiting: boolean;
    readonly previousValue: Schema_.OptionEncoded<A>;
    readonly cause: Schema_.CauseEncoded<E, unknown>;
};
/**
 * @since 1.0.0
 * @category Schemas
 */
export declare const schemaFromSelf: Schema_.Schema<Result<any, any>>;
/**
 * @since 1.0.0
 * @category Schemas
 */
export declare const Schema: <Success extends Schema_.Schema.All = typeof Schema_.Never, Error extends Schema_.Schema.All = typeof Schema_.Never>(options: {
    readonly success?: Success | undefined;
    readonly error?: Error | undefined;
}) => Schema_.transform<Schema_.Schema<PartialEncoded<Success["Type"], Error["Type"]>, Encoded<Success["Encoded"], Error["Encoded"]>, Success["Context"] | Error["Context"]>, Schema_.Schema<Result<Success["Type"], Error["Type"]>>>;
//# sourceMappingURL=Result.d.ts.map