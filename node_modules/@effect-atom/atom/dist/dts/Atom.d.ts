/**
 * @since 1.0.0
 */
import * as Reactivity from "@effect/experimental/Reactivity";
import * as KeyValueStore from "@effect/platform/KeyValueStore";
import * as Arr from "effect/Array";
import { NoSuchElementException } from "effect/Cause";
import * as Cause from "effect/Cause";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import type { LazyArg } from "effect/Function";
import * as Inspectable from "effect/Inspectable";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import { type Pipeable } from "effect/Pipeable";
import type { ReadonlyRecord } from "effect/Record";
import * as Runtime from "effect/Runtime";
import * as Schema from "effect/Schema";
import * as Scope from "effect/Scope";
import * as Stream from "effect/Stream";
import * as Subscribable from "effect/Subscribable";
import * as SubscriptionRef from "effect/SubscriptionRef";
import type { NoInfer } from "effect/Types";
import * as Registry from "./Registry.js";
import { AtomRegistry as AtomRegistry } from "./Registry.js";
import * as Result from "./Result.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: TypeId;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = "~effect-atom/atom/Atom";
/**
 * @since 1.0.0
 * @category models
 */
export interface Atom<A> extends Pipeable, Inspectable.Inspectable {
    readonly [TypeId]: TypeId;
    readonly keepAlive: boolean;
    readonly lazy: boolean;
    readonly read: (get: Context) => A;
    readonly refresh?: (f: <A>(atom: Atom<A>) => void) => void;
    readonly label?: readonly [name: string, stack: string];
    readonly idleTTL?: number;
}
/**
 * @since 1.0.0
 * @category Guards
 */
export declare const isAtom: (u: unknown) => u is Atom<any>;
/**
 * @since 1.0.0
 */
export type Type<T extends Atom<any>> = T extends Atom<infer A> ? A : never;
/**
 * @since 1.0.0
 */
export type Success<T extends Atom<any>> = T extends Atom<Result.Result<infer A, infer _>> ? A : never;
/**
 * @since 1.0.0
 */
export type PullSuccess<T extends Atom<any>> = T extends Atom<PullResult<infer A, infer _>> ? A : never;
/**
 * @since 1.0.0
 */
export type Failure<T extends Atom<any>> = T extends Atom<Result.Result<infer _, infer E>> ? E : never;
/**
 * @since 1.0.0
 */
export type WithoutSerializable<T extends Atom<any>> = T extends Writable<infer R, infer W> ? Writable<R, W> : Atom<Type<T>>;
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const WritableTypeId: WritableTypeId;
/**
 * @since 1.0.0
 * @category type ids
 */
export type WritableTypeId = "~effect-atom/atom/Atom/Writable";
/**
 * @since 1.0.0
 * @category models
 */
export interface Writable<R, W = R> extends Atom<R> {
    readonly [WritableTypeId]: WritableTypeId;
    readonly write: (ctx: WriteContext<R>, value: W) => void;
}
/**
 * @since 1.0.0
 * @category context
 */
export interface Context {
    <A>(atom: Atom<A>): A;
    get<A>(this: Context, atom: Atom<A>): A;
    result<A, E>(this: Context, atom: Atom<Result.Result<A, E>>, options?: {
        readonly suspendOnWaiting?: boolean | undefined;
    }): Effect.Effect<A, E>;
    resultOnce<A, E>(this: Context, atom: Atom<Result.Result<A, E>>, options?: {
        readonly suspendOnWaiting?: boolean | undefined;
    }): Effect.Effect<A, E>;
    once<A>(this: Context, atom: Atom<A>): A;
    addFinalizer(this: Context, f: () => void): void;
    mount<A>(this: Context, atom: Atom<A>): void;
    refresh<A>(this: Context, atom: Atom<A>): void;
    refreshSelf(this: Context): void;
    self<A>(this: Context): Option.Option<A>;
    setSelf<A>(this: Context, a: A): void;
    set<R, W>(this: Context, atom: Writable<R, W>, value: W): void;
    setResult<A, E, W>(this: Context, atom: Writable<Result.Result<A, E>, W>, value: W): Effect.Effect<A, E>;
    some<A>(this: Context, atom: Atom<Option.Option<A>>): Effect.Effect<A>;
    someOnce<A>(this: Context, atom: Atom<Option.Option<A>>): Effect.Effect<A>;
    stream<A>(this: Context, atom: Atom<A>, options?: {
        readonly withoutInitialValue?: boolean;
        readonly bufferSize?: number;
    }): Stream.Stream<A>;
    streamResult<A, E>(this: Context, atom: Atom<Result.Result<A, E>>, options?: {
        readonly withoutInitialValue?: boolean;
        readonly bufferSize?: number;
    }): Stream.Stream<A, E>;
    subscribe<A>(this: Context, atom: Atom<A>, f: (_: A) => void, options?: {
        readonly immediate?: boolean;
    }): void;
    readonly registry: Registry.Registry;
}
/**
 * @since 1.0.0
 * @category context
 */
export interface WriteContext<A> {
    get<T>(this: WriteContext<A>, atom: Atom<T>): T;
    refreshSelf(this: WriteContext<A>): void;
    setSelf(this: WriteContext<A>, a: A): void;
    set<R, W>(this: WriteContext<A>, atom: Writable<R, W>, value: W): void;
}
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const setIdleTTL: {
    (duration: Duration.DurationInput): <A extends Atom<any>>(self: A) => A;
    <A extends Atom<any>>(self: A, duration: Duration.DurationInput): A;
};
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isWritable: <R, W>(atom: Atom<R>) => atom is Writable<R, W>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const readable: <A>(read: (get: Context) => A, refresh?: (f: <A_1>(atom: Atom<A_1>) => void) => void) => Atom<A>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const writable: <R, W>(read: (get: Context) => R, write: (ctx: WriteContext<R>, value: W) => void, refresh?: (f: <A>(atom: Atom<A>) => void) => void) => Writable<R, W>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const make: {
    <A, E>(create: (get: Context) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {
        readonly initialValue?: A;
    }): Atom<Result.Result<A, E>>;
    <A, E>(effect: Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {
        readonly initialValue?: A;
    }): Atom<Result.Result<A, E>>;
    <A, E>(create: (get: Context) => Stream.Stream<A, E, AtomRegistry>, options?: {
        readonly initialValue?: A;
    }): Atom<Result.Result<A, E>>;
    <A, E>(stream: Stream.Stream<A, E, AtomRegistry>, options?: {
        readonly initialValue?: A;
    }): Atom<Result.Result<A, E>>;
    <A>(create: (get: Context) => A): Atom<A>;
    <A>(initialValue: A): Writable<A>;
};
/**
 * @since 1.0.0
 * @category models
 */
export interface AtomRuntime<R, ER = never> extends Atom<Result.Result<Runtime.Runtime<R>, ER>> {
    readonly factory: RuntimeFactory;
    readonly layer: Atom<Layer.Layer<R, ER>>;
    readonly atom: {
        <A, E>(create: (get: Context) => Effect.Effect<A, E, Scope.Scope | R | AtomRegistry | Reactivity.Reactivity>, options?: {
            readonly initialValue?: A;
        }): Atom<Result.Result<A, E | ER>>;
        <A, E>(effect: Effect.Effect<A, E, Scope.Scope | R | AtomRegistry | Reactivity.Reactivity>, options?: {
            readonly initialValue?: A;
        }): Atom<Result.Result<A, E | ER>>;
        <A, E>(create: (get: Context) => Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>, options?: {
            readonly initialValue?: A;
        }): Atom<Result.Result<A, E | ER>>;
        <A, E>(stream: Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>, options?: {
            readonly initialValue?: A;
        }): Atom<Result.Result<A, E | ER>>;
    };
    readonly fn: {
        <Arg>(): {
            <E, A>(fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry | Reactivity.Reactivity | R>, options?: {
                readonly initialValue?: A | undefined;
                readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined;
                readonly concurrent?: boolean | undefined;
            }): AtomResultFn<Arg, A, E | ER>;
            <E, A>(fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>, options?: {
                readonly initialValue?: A | undefined;
                readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined;
                readonly concurrent?: boolean | undefined;
            }): AtomResultFn<Arg, A, E | ER | NoSuchElementException>;
        };
        <E, A, Arg = void>(fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry | Reactivity.Reactivity | R>, options?: {
            readonly initialValue?: A | undefined;
            readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined;
            readonly concurrent?: boolean | undefined;
        }): AtomResultFn<Arg, A, E | ER>;
        <E, A, Arg = void>(fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>, options?: {
            readonly initialValue?: A | undefined;
            readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined;
            readonly concurrent?: boolean | undefined;
        }): AtomResultFn<Arg, A, E | ER | NoSuchElementException>;
    };
    readonly pull: <A, E>(create: ((get: Context) => Stream.Stream<A, E, R | AtomRegistry | Reactivity.Reactivity>) | Stream.Stream<A, E, R | AtomRegistry | Reactivity.Reactivity>, options?: {
        readonly disableAccumulation?: boolean;
        readonly initialValue?: ReadonlyArray<A>;
    }) => Writable<PullResult<A, E | ER>, void>;
    readonly subscriptionRef: <A, E>(create: Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, R | AtomRegistry | Reactivity.Reactivity> | ((get: Context) => Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, R | AtomRegistry | Reactivity.Reactivity>)) => Writable<Result.Result<A, E>, A>;
    readonly subscribable: <A, E, E1 = never>(create: Effect.Effect<Subscribable.Subscribable<A, E, R>, E1, R | AtomRegistry | Reactivity.Reactivity> | ((get: Context) => Effect.Effect<Subscribable.Subscribable<A, E, R>, E1, R | AtomRegistry | Reactivity.Reactivity>)) => Atom<Result.Result<A, E | E1>>;
}
/**
 * @since 1.0.0
 * @category models
 */
export interface RuntimeFactory {
    <R, E>(create: Layer.Layer<R, E, AtomRegistry | Reactivity.Reactivity> | ((get: Context) => Layer.Layer<R, E, AtomRegistry | Reactivity.Reactivity>)): AtomRuntime<R, E>;
    readonly memoMap: Layer.MemoMap;
    readonly addGlobalLayer: <A, E>(layer: Layer.Layer<A, E, AtomRegistry | Reactivity.Reactivity>) => void;
    /**
     * Uses the `Reactivity` service from the runtime to refresh the atom whenever
     * the keys change.
     */
    readonly withReactivity: (keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>) => <A extends Atom<any>>(atom: A) => A;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const context: (options: {
    readonly memoMap: Layer.MemoMap;
}) => RuntimeFactory;
/**
 * @since 1.0.0
 * @category context
 */
export declare const defaultMemoMap: Layer.MemoMap;
/**
 * @since 1.0.0
 * @category context
 */
export declare const runtime: RuntimeFactory;
/**
 * An alias to `Rx.runtime.withReactivity`, for refreshing an atom whenever the
 * keys change in the `Reactivity` service.
 *
 * @since 1.0.0
 * @category Reactivity
 */
export declare const withReactivity: (keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>) => <A extends Atom<any>>(atom: A) => A;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const subscriptionRef: {
    <A>(ref: SubscriptionRef.SubscriptionRef<A> | ((get: Context) => SubscriptionRef.SubscriptionRef<A>)): Writable<A>;
    <A, E>(effect: Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, Scope.Scope | AtomRegistry> | ((get: Context) => Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, Scope.Scope | AtomRegistry>)): Writable<Result.Result<A, E>, A>;
};
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const subscribable: {
    <A, E>(ref: Subscribable.Subscribable<A, E> | ((get: Context) => Subscribable.Subscribable<A, E>)): Atom<A>;
    <A, E, E1>(effect: Effect.Effect<Subscribable.Subscribable<A, E1>, E, Scope.Scope | AtomRegistry> | ((get: Context) => Effect.Effect<Subscribable.Subscribable<A, E1>, E, Scope.Scope | AtomRegistry>)): Atom<Result.Result<A, E | E1>>;
};
/**
 * @since 1.0.0
 * @category models
 */
export interface FnContext {
    <A>(atom: Atom<A>): A;
    result<A, E>(this: FnContext, atom: Atom<Result.Result<A, E>>, options?: {
        readonly suspendOnWaiting?: boolean | undefined;
    }): Effect.Effect<A, E>;
    addFinalizer(this: FnContext, f: () => void): void;
    mount<A>(this: FnContext, atom: Atom<A>): void;
    refresh<A>(this: FnContext, atom: Atom<A>): void;
    self<A>(this: FnContext): Option.Option<A>;
    setSelf<A>(this: FnContext, a: A): void;
    set<R, W>(this: FnContext, atom: Writable<R, W>, value: W): void;
    setResult<A, E, W>(this: FnContext, atom: Writable<Result.Result<A, E>, W>, value: W): Effect.Effect<A, E>;
    some<A>(this: FnContext, atom: Atom<Option.Option<A>>): Effect.Effect<A>;
    stream<A>(this: FnContext, atom: Atom<A>, options?: {
        readonly withoutInitialValue?: boolean;
        readonly bufferSize?: number;
    }): Stream.Stream<A>;
    streamResult<A, E>(this: FnContext, atom: Atom<Result.Result<A, E>>, options?: {
        readonly withoutInitialValue?: boolean;
        readonly bufferSize?: number;
    }): Stream.Stream<A, E>;
    subscribe<A>(this: FnContext, atom: Atom<A>, f: (_: A) => void, options?: {
        readonly immediate?: boolean;
    }): void;
    readonly registry: Registry.Registry;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const fnSync: {
    <Arg>(): {
        <A>(f: (arg: Arg, get: FnContext) => A): Writable<Option.Option<A>, Arg>;
        <A>(f: (arg: Arg, get: FnContext) => A, options: {
            readonly initialValue: A;
        }): Writable<A, Arg>;
    };
    <A, Arg = void>(f: (arg: Arg, get: FnContext) => A): Writable<Option.Option<A>, Arg>;
    <A, Arg = void>(f: (arg: Arg, get: FnContext) => A, options: {
        readonly initialValue: A;
    }): Writable<A, Arg>;
};
/**
 * @since 1.0.0
 * @category models
 */
export interface AtomResultFn<Arg, A, E = never> extends Writable<Result.Result<A, E>, Arg | Reset | Interrupt> {
}
/**
 * @since 1.0.0
 * @category symbols
 */
export declare const Reset: unique symbol;
/**
 * @since 1.0.0
 * @category symbols
 */
export type Reset = typeof Reset;
/**
 * @since 1.0.0
 * @category symbols
 */
export declare const Interrupt: unique symbol;
/**
 * @since 1.0.0
 * @category symbols
 */
export type Interrupt = typeof Interrupt;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const fn: {
    <Arg>(): <E, A>(fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {
        readonly initialValue?: A | undefined;
        readonly concurrent?: boolean | undefined;
    }) => AtomResultFn<Arg, A, E>;
    <E, A, Arg = void>(fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {
        readonly initialValue?: A | undefined;
        readonly concurrent?: boolean | undefined;
    }): AtomResultFn<Arg, A, E>;
    <Arg>(): <E, A>(fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry>, options?: {
        readonly initialValue?: A | undefined;
        readonly concurrent?: boolean | undefined;
    }) => AtomResultFn<Arg, A, E | NoSuchElementException>;
    <E, A, Arg = void>(fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry>, options?: {
        readonly initialValue?: A | undefined;
        readonly concurrent?: boolean | undefined;
    }): AtomResultFn<Arg, A, E | NoSuchElementException>;
};
/**
 * @since 1.0.0
 * @category models
 */
export type PullResult<A, E = never> = Result.Result<{
    readonly done: boolean;
    readonly items: Arr.NonEmptyArray<A>;
}, E | Cause.NoSuchElementException>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const pull: <A, E>(create: ((get: Context) => Stream.Stream<A, E, AtomRegistry>) | Stream.Stream<A, E, AtomRegistry>, options?: {
    readonly disableAccumulation?: boolean | undefined;
}) => Writable<PullResult<A, E>, void>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const family: <Arg, T extends object>(f: (arg: Arg) => T) => (arg: Arg) => T;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withFallback: {
    <E2, A2>(fallback: Atom<Result.Result<A2, E2>>): <R extends Atom<Result.Result<any, any>>>(self: R) => [R] extends [Writable<infer _, infer RW>] ? Writable<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>, RW> : Atom<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>>;
    <R extends Atom<Result.Result<any, any>>, A2, E2>(self: R, fallback: Atom<Result.Result<A2, E2>>): [R] extends [Writable<infer _, infer RW>] ? Writable<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>, RW> : Atom<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const keepAlive: <A extends Atom<any>>(self: A) => A;
/**
 * Reverts the `keepAlive` behavior of a reactive value, allowing it to be
 * disposed of when not in use.
 *
 * Note that Atom's have this behavior by default.
 *
 * @since 1.0.0
 * @category combinators
 */
export declare const autoDispose: <A extends Atom<any>>(self: A) => A;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const setLazy: {
    (lazy: boolean): <A extends Atom<any>>(self: A) => A;
    <A extends Atom<any>>(self: A, lazy: boolean): A;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withLabel: {
    (name: string): <A extends Atom<any>>(self: A) => A;
    <A extends Atom<any>>(self: A, name: string): A;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const initialValue: {
    <A>(initialValue: A): (self: Atom<A>) => readonly [Atom<A>, A];
    <A>(self: Atom<A>, initialValue: A): readonly [Atom<A>, A];
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const transform: {
    <R extends Atom<any>, B>(f: (get: Context) => B): (self: R) => [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>;
    <R extends Atom<any>, B>(self: R, f: (get: Context) => B): [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const map: {
    <R extends Atom<any>, B>(f: (_: Type<R>) => B): (self: R) => [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>;
    <R extends Atom<any>, B>(self: R, f: (_: Type<R>) => B): [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const mapResult: {
    <R extends Atom<Result.Result<any, any>>, B>(f: (_: Result.Result.Success<Type<R>>) => B): (self: R) => [R] extends [Writable<infer _, infer RW>] ? Writable<Result.Result<B, Result.Result.Failure<Type<R>>>, RW> : Atom<Result.Result<B, Result.Result.Failure<Type<R>>>>;
    <R extends Atom<Result.Result<any, any>>, B>(self: R, f: (_: Result.Result.Success<Type<R>>) => B): [R] extends [Writable<infer _, infer RW>] ? Writable<Result.Result<B, Result.Result.Failure<Type<R>>>, RW> : Atom<Result.Result<B, Result.Result.Failure<Type<R>>>>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const debounce: {
    (duration: Duration.DurationInput): <A extends Atom<any>>(self: A) => WithoutSerializable<A>;
    <A extends Atom<any>>(self: A, duration: Duration.DurationInput): WithoutSerializable<A>;
};
/**
 * @since 1.0.0
 * @category Optimistic
 */
export declare const optimistic: <A>(self: Atom<A>) => Writable<A, Atom<Result.Result<A, unknown>>>;
/**
 * @since 1.0.0
 * @category Optimistic
 */
export declare const optimisticFn: {
    <A, W, XA, XE, OW = void>(options: {
        readonly reducer: (current: NoInfer<A>, update: OW) => NoInfer<W>;
        readonly fn: AtomResultFn<OW, XA, XE> | ((set: (result: NoInfer<W>) => void) => AtomResultFn<OW, XA, XE>);
    }): (self: Writable<A, Atom<Result.Result<W, unknown>>>) => AtomResultFn<OW, XA, XE>;
    <A, W, XA, XE, OW = void>(self: Writable<A, Atom<Result.Result<W, unknown>>>, options: {
        readonly reducer: (current: NoInfer<A>, update: OW) => NoInfer<W>;
        readonly fn: AtomResultFn<OW, XA, XE> | ((set: (result: NoInfer<W>) => void) => AtomResultFn<OW, XA, XE>);
    }): AtomResultFn<OW, XA, XE>;
};
/**
 * @since 1.0.0
 * @category batching
 */
export declare const batch: (f: () => void) => void;
/**
 * @since 1.0.0
 * @category Focus
 */
export declare const windowFocusSignal: Atom<number>;
/**
 * @since 1.0.0
 * @category Focus
 */
export declare const makeRefreshOnSignal: <_>(signal: Atom<_>) => <A extends Atom<any>>(self: A) => WithoutSerializable<A>;
/**
 * @since 1.0.0
 * @category Focus
 */
export declare const refreshOnWindowFocus: <A extends Atom<any>>(self: A) => WithoutSerializable<A>;
/**
 * @since 1.0.0
 * @category KeyValueStore
 */
export declare const kvs: <A>(options: {
    readonly runtime: AtomRuntime<KeyValueStore.KeyValueStore, any>;
    readonly key: string;
    readonly schema: Schema.Schema<A, any>;
    readonly defaultValue: LazyArg<A>;
}) => Writable<A>;
/**
 * Create an Atom that reads and writes a URL search parameter.
 *
 * Note: If you pass a schema, it has to be synchronous and have no context.
 *
 * @since 1.0.0
 * @category URL search params
 */
export declare const searchParam: <A = never, I extends string = never>(name: string, options?: {
    readonly schema?: Schema.Schema<A, I>;
}) => Writable<[A] extends [never] ? string : Option.Option<A>>;
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const toStream: <A>(self: Atom<A>) => Stream.Stream<A, never, AtomRegistry>;
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const toStreamResult: <A, E>(self: Atom<Result.Result<A, E>>) => Stream.Stream<A, E, AtomRegistry>;
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const get: <A>(self: Atom<A>) => Effect.Effect<A, never, AtomRegistry>;
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const modify: {
    <R, W, A>(f: (_: R) => [returnValue: A, nextValue: W]): (self: Writable<R, W>) => Effect.Effect<A, never, AtomRegistry>;
    <R, W, A>(self: Writable<R, W>, f: (_: R) => [returnValue: A, nextValue: W]): Effect.Effect<A, never, AtomRegistry>;
};
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const set: {
    <W>(value: W): <R>(self: Writable<R, W>) => Effect.Effect<void, never, AtomRegistry>;
    <R, W>(self: Writable<R, W>, value: W): Effect.Effect<void, never, AtomRegistry>;
};
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const update: {
    <R, W>(f: (_: R) => W): (self: Writable<R, W>) => Effect.Effect<void, never, AtomRegistry>;
    <R, W>(self: Writable<R, W>, f: (_: R) => W): Effect.Effect<void, never, AtomRegistry>;
};
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const getResult: <A, E>(self: Atom<Result.Result<A, E>>, options?: {
    readonly suspendOnWaiting?: boolean | undefined;
}) => Effect.Effect<A, E, AtomRegistry>;
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const refresh: <A>(self: Atom<A>) => Effect.Effect<void, never, AtomRegistry>;
/**
 * @since 1.0.0
 * @category Serializable
 */
export declare const SerializableTypeId: SerializableTypeId;
/**
 * @since 1.0.0
 * @category Serializable
 */
export type SerializableTypeId = "~effect-atom/atom/Atom/Serializable";
/**
 * @since 1.0.0
 * @category Serializable
 */
export interface Serializable {
    readonly [SerializableTypeId]: {
        readonly key: string;
        readonly encode: (value: unknown) => unknown;
        readonly decode: (value: unknown) => unknown;
    };
}
/**
 * @since 1.0.0
 * @category Serializable
 */
export declare const isSerializable: (self: Atom<any>) => self is Atom<any> & Serializable;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const serializable: {
    <R extends Atom<any>, I>(options: {
        readonly key: string;
        readonly schema: Schema.Schema<Type<R>, I>;
    }): (self: R) => R & Serializable;
    <R extends Atom<any>, I>(self: R, options: {
        readonly key: string;
        readonly schema: Schema.Schema<Type<R>, I>;
    }): R & Serializable;
};
/**
 * @since 1.0.0
 * @category ServerValue
 */
export declare const ServerValueTypeId: "~effect-atom/atom/Atom/ServerValue";
/**
 * Overrides the value of an Atom when read on the server.
 *
 * @since 1.0.0
 * @category ServerValue
 */
export declare const withServerValue: {
    <A extends Atom<any>>(read: (get: <A>(atom: Atom<A>) => A) => Type<A>): (self: A) => A;
    <A extends Atom<any>>(self: A, read: (get: <A>(atom: Atom<A>) => A) => Type<A>): A;
};
/**
 * Sets the Atom's server value to `Result.initial(true)`.
 *
 * @since 1.0.0
 * @category ServerValue
 */
export declare const withServerValueInitial: <A extends Atom<Result.Result<any, any>>>(self: A) => A;
/**
 * @since 1.0.0
 * @category ServerValue
 */
export declare const getServerValue: {
    (registry: Registry.Registry): <A>(self: Atom<A>) => A;
    <A>(self: Atom<A>, registry: Registry.Registry): A;
};
//# sourceMappingURL=Atom.d.ts.map