/**
 * @since 1.0.0
 */
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Stream from "effect/Stream";
import type * as Atom from "./Atom.js";
import type { Registry } from "./index.js";
import * as Result from "./Result.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: TypeId;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = "~effect-atom/atom/Registry";
/**
 * @since 1.0.0
 * @category guards
 */
export declare const isRegistry: (u: unknown) => u is Registry;
/**
 * @since 1.0.0
 * @category models
 */
export interface Registry {
    readonly [TypeId]: TypeId;
    readonly getNodes: () => ReadonlyMap<Atom.Atom<any> | string, Node<any>>;
    readonly get: <A>(atom: Atom.Atom<A>) => A;
    readonly mount: <A>(atom: Atom.Atom<A>) => () => void;
    readonly refresh: <A>(atom: Atom.Atom<A>) => void;
    readonly set: <R, W>(atom: Atom.Writable<R, W>, value: W) => void;
    readonly setSerializable: (key: string, encoded: unknown) => void;
    readonly modify: <R, W, A>(atom: Atom.Writable<R, W>, f: (_: R) => [returnValue: A, nextValue: W]) => A;
    readonly update: <R, W>(atom: Atom.Writable<R, W>, f: (_: R) => W) => void;
    readonly subscribe: <A>(atom: Atom.Atom<A>, f: (_: A) => void, options?: {
        readonly immediate?: boolean;
    }) => () => void;
    readonly reset: () => void;
    readonly dispose: () => void;
}
/**
 * @since 1.0.0
 * @category models
 */
interface Node<A> {
    readonly atom: Atom.Atom<A>;
    readonly value: () => A;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const make: (options?: {
    readonly initialValues?: Iterable<readonly [Atom.Atom<any>, any]> | undefined;
    readonly scheduleTask?: ((f: () => void) => void) | undefined;
    readonly timeoutResolution?: number | undefined;
    readonly defaultIdleTTL?: number | undefined;
} | undefined) => Registry;
declare const AtomRegistry_base: Context.TagClass<Registry.AtomRegistry, "@effect/atom/Registry/CurrentRegistry", Registry.Registry>;
/**
 * @since 1.0.0
 * @category Tags
 */
export declare class AtomRegistry extends AtomRegistry_base {
}
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerOptions: (options?: {
    readonly initialValues?: Iterable<readonly [Atom.Atom<any>, any]> | undefined;
    readonly scheduleTask?: ((f: () => void) => void) | undefined;
    readonly timeoutResolution?: number | undefined;
    readonly defaultIdleTTL?: number | undefined;
}) => Layer.Layer<AtomRegistry>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layer: Layer.Layer<Registry.AtomRegistry>;
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const toStream: {
    <A>(atom: Atom.Atom<A>): (self: Registry) => Stream.Stream<A>;
    <A>(self: Registry, atom: Atom.Atom<A>): Stream.Stream<A>;
};
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const toStreamResult: {
    <A, E>(atom: Atom.Atom<Result.Result<A, E>>): (self: Registry) => Stream.Stream<A, E>;
    <A, E>(self: Registry, atom: Atom.Atom<Result.Result<A, E>>): Stream.Stream<A, E>;
};
/**
 * @since 1.0.0
 * @category Conversions
 */
export declare const getResult: {
    <A, E>(atom: Atom.Atom<Result.Result<A, E>>, options?: {
        readonly suspendOnWaiting?: boolean | undefined;
    }): (self: Registry) => Effect.Effect<A, E>;
    <A, E>(self: Registry, atom: Atom.Atom<Result.Result<A, E>>, options?: {
        readonly suspendOnWaiting?: boolean | undefined;
    }): Effect.Effect<A, E>;
};
export {};
//# sourceMappingURL=Registry.d.ts.map