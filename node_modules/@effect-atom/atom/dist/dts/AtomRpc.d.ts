import * as Headers from "@effect/platform/Headers";
import type * as Rpc from "@effect/rpc/Rpc";
import * as RpcClient from "@effect/rpc/RpcClient";
import type { RpcClientError } from "@effect/rpc/RpcClientError";
import type * as RpcGroup from "@effect/rpc/RpcGroup";
import type { RequestId } from "@effect/rpc/RpcMessage";
import * as RpcSchema from "@effect/rpc/RpcSchema";
import * as Context from "effect/Context";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import type { ReadonlyRecord } from "effect/Record";
import type { Scope } from "effect/Scope";
import type { NoInfer } from "effect/Types";
import * as Atom from "./Atom.js";
import type * as Result from "./Result.js";
/**
 * @since 1.0.0
 * @category Models
 */
export interface AtomRpcClient<Self, Id extends string, Rpcs extends Rpc.Any, E> extends Context.Tag<Self, RpcClient.RpcClient.Flat<Rpcs, RpcClientError>> {
    new (_: never): Context.TagClassShape<Id, RpcClient.RpcClient.Flat<Rpcs, RpcClientError>>;
    readonly layer: Layer.Layer<Self, E>;
    readonly runtime: Atom.AtomRuntime<Self, E>;
    readonly mutation: <Tag extends Rpc.Tag<Rpcs>>(arg: Tag) => Rpc.ExtractTag<Rpcs, Tag> extends Rpc.Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? never : Atom.AtomResultFn<{
        readonly payload: Rpc.PayloadConstructor<Rpc.ExtractTag<Rpcs, Tag>>;
        readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined;
        readonly headers?: Headers.Input | undefined;
    }, _Success["Type"], _Error["Type"] | E | _Middleware["failure"]["Type"]> : never;
    readonly query: <Tag extends Rpc.Tag<Rpcs>>(tag: Tag, payload: Rpc.PayloadConstructor<Rpc.ExtractTag<Rpcs, Tag>>, options?: {
        readonly headers?: Headers.Input | undefined;
        readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined;
        readonly timeToLive?: Duration.DurationInput | undefined;
    }) => Rpc.ExtractTag<Rpcs, Tag> extends Rpc.Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? Atom.Writable<Atom.PullResult<_A["Type"], _E["Type"] | _Error["Type"] | E | _Middleware["failure"]["Type"]>, void> : Atom.Atom<Result.Result<_Success["Type"], _Error["Type"] | E | _Middleware["failure"]["Type"]>> : never;
}
declare global {
    interface ErrorConstructor {
        stackTraceLimit: number;
    }
}
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const Tag: <Self>() => <const Id extends string, Rpcs extends Rpc.Any, ER, RM = RpcClient.Protocol | Rpc.MiddlewareClient<NoInfer<Rpcs>> | Rpc.Context<NoInfer<Rpcs>>>(id: Id, options: {
    readonly group: RpcGroup.RpcGroup<Rpcs>;
    readonly protocol: Layer.Layer<Exclude<NoInfer<RM>, Scope>, ER>;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly generateRequestId?: (() => RequestId) | undefined;
    readonly disableTracing?: boolean | undefined;
    readonly makeEffect?: Effect.Effect<RpcClient.RpcClient.Flat<Rpcs, RpcClientError>, never, RM> | undefined;
}) => AtomRpcClient<Self, Id, Rpcs, ER>;
//# sourceMappingURL=AtomRpc.d.ts.map