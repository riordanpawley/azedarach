"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hydrate = exports.dehydrate = void 0;
var Arr = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Array"));
var Atom = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("./Atom.js"));
var Result = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("./Result.js"));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category dehydration
 */
const dehydrate = (registry, options) => {
  const encodeInitialResultMode = options?.encodeInitialAs ?? "ignore";
  const arr = Arr.empty();
  const now = Date.now();
  registry.getNodes().forEach((node, key) => {
    if (!Atom.isSerializable(node.atom)) return;
    const atom = node.atom;
    const value = node.value();
    const isInitial = Result.isResult(value) && Result.isInitial(value);
    if (encodeInitialResultMode === "ignore" && isInitial) return;
    const encodedValue = atom[Atom.SerializableTypeId].encode(value);
    // Create a promise that resolves when the atom moves out of Initial state
    let resultPromise;
    if (encodeInitialResultMode === "promise" && isInitial) {
      resultPromise = new Promise(resolve => {
        const unsubscribe = registry.subscribe(atom, newValue => {
          if (Result.isResult(newValue) && !Result.isInitial(newValue)) {
            resolve(atom[Atom.SerializableTypeId].encode(newValue));
            unsubscribe();
          }
        });
      });
    }
    arr.push({
      key: key,
      value: encodedValue,
      dehydratedAt: now,
      resultPromise
    });
  });
  return arr;
};
/**
 * @since 1.0.0
 * @category hydration
 */
exports.dehydrate = dehydrate;
const hydrate = (registry, dehydratedState) => {
  for (const datom of dehydratedState) {
    registry.setSerializable(datom.key, datom.value);
    // If there's a resultPromise, it means this was in Initial state when dehydrated
    // and we should wait for it to resolve to a non-Initial state, then update the registry
    if (!datom.resultPromise) continue;
    datom.resultPromise.then(resolvedValue => {
      // Try to update the existing node directly instead of using setSerializable
      const nodes = registry.getNodes();
      const node = nodes.get(datom.key);
      if (node) {
        // Decode the resolved value using the node's atom serializable decoder
        const atom = node.atom;
        if (atom[Atom.SerializableTypeId]) {
          const decoded = atom[Atom.SerializableTypeId].decode(resolvedValue);
          node.setValue(decoded);
        }
      } else {
        // Fallback to setSerializable if node doesn't exist yet
        registry.setSerializable(datom.key, resolvedValue);
      }
    });
  }
};
exports.hydrate = hydrate;
//# sourceMappingURL=Hydration.js.map