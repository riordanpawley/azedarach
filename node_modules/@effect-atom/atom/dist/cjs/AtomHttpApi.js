"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tag = void 0;
var Reactivity = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect/experimental/Reactivity"));
var HttpApiClient = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect/platform/HttpApiClient"));
var Context = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Context"));
var Data = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Data"));
var Duration = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Duration"));
var Effect = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Effect"));
var Equal = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Equal"));
var _Function = /*#__PURE__*/require("effect/Function");
var Hash = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Hash"));
var Layer = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Layer"));
var Atom = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("./Atom.js"));
var _data = /*#__PURE__*/require("./internal/data.js");
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category Constructors
 */
const Tag = () => (id, options) => {
  const self = Context.Tag(id)();
  self.layer = Layer.scoped(self, HttpApiClient.make(options.api, options)).pipe(Layer.provide(options.httpClient));
  self.runtime = Atom.runtime(self.layer);
  const mutationFamily = Atom.family(({
    endpoint,
    group,
    withResponse
  }) => self.runtime.fn()(Effect.fnUntraced(function* (opts) {
    const client = yield* self;
    const effect = client[group][endpoint]({
      ...opts,
      withResponse
    });
    return yield* opts.reactivityKeys ? Reactivity.mutation(effect, opts.reactivityKeys) : effect;
  })));
  self.mutation = (group, endpoint, options) => mutationFamily(new MutationKey({
    group,
    endpoint,
    withResponse: options?.withResponse ?? false
  }));
  const queryFamily = Atom.family(opts => {
    let atom = self.runtime.atom(Effect.flatMap(self, client_ => {
      const client = client_;
      return client[opts.group][opts.endpoint](opts);
    }));
    if (opts.timeToLive) {
      atom = Duration.isFinite(opts.timeToLive) ? Atom.setIdleTTL(atom, opts.timeToLive) : Atom.keepAlive(atom);
    }
    return opts.reactivityKeys ? self.runtime.factory.withReactivity(opts.reactivityKeys)(atom) : atom;
  });
  self.query = (group, endpoint, request) => queryFamily(new QueryKey({
    group,
    endpoint,
    path: request.path && Data.struct(request.path),
    urlParams: request.urlParams && Data.struct(request.urlParams),
    payload: request.payload && Data.struct(request.payload),
    headers: request.headers && Data.struct(request.headers),
    withResponse: request.withResponse ?? false,
    reactivityKeys: request.reactivityKeys ? (0, _data.wrapReactivityKeys)(request.reactivityKeys) : undefined,
    timeToLive: request.timeToLive ? Duration.decode(request.timeToLive) : undefined
  }));
  return self;
};
exports.Tag = Tag;
class MutationKey extends Data.Class {
  [Equal.symbol](that) {
    return this.group === that.group && this.endpoint === that.endpoint && this.withResponse === that.withResponse;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.string(`${this.group}/${this.endpoint}/${this.withResponse}`), Hash.cached(this));
  }
}
class QueryKey extends Data.Class {
  [Equal.symbol](that) {
    return this.group === that.group && this.endpoint === that.endpoint && Equal.equals(this.path, that.path) && Equal.equals(this.urlParams, that.urlParams) && Equal.equals(this.payload, that.payload) && Equal.equals(this.headers, that.headers) && Equal.equals(this.withResponse, that.withResponse) && Equal.equals(this.reactivityKeys, that.reactivityKeys) && Equal.equals(this.timeToLive, that.timeToLive);
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.string(`${this.group}/${this.endpoint}`), Hash.combine(Hash.hash(this.path)), Hash.combine(Hash.hash(this.urlParams)), Hash.combine(Hash.hash(this.payload)), Hash.combine(Hash.hash(this.headers)), Hash.combine(Hash.hash(this.withResponse)), Hash.combine(Hash.hash(this.reactivityKeys)), Hash.combine(Hash.hash(this.timeToLive)), Hash.cached(this));
  }
}
//# sourceMappingURL=AtomHttpApi.js.map