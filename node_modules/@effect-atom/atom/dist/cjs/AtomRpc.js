"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tag = void 0;
var Reactivity = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect/experimental/Reactivity"));
var Headers = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect/platform/Headers"));
var RpcClient = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect/rpc/RpcClient"));
var RpcSchema = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("@effect/rpc/RpcSchema"));
var Context = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Context"));
var Data = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Data"));
var Duration = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Duration"));
var Effect = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Effect"));
var Equal = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Equal"));
var _Function = /*#__PURE__*/require("effect/Function");
var Hash = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Hash"));
var Layer = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Layer"));
var Stream = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Stream"));
var Atom = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("./Atom.js"));
var _data = /*#__PURE__*/require("./internal/data.js");
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category Constructors
 */
const Tag = () => (id, options) => {
  const self = Context.Tag(id)();
  self.layer = Layer.scoped(self, options.makeEffect ?? RpcClient.make(options.group, {
    ...options,
    flatten: true
  })).pipe(Layer.provide(options.protocol));
  self.runtime = Atom.runtime(self.layer);
  self.mutation = Atom.family(tag => self.runtime.fn()(Effect.fnUntraced(function* ({
    headers,
    payload,
    reactivityKeys
  }) {
    const client = yield* self;
    const effect = client(tag, payload, {
      headers
    });
    return yield* reactivityKeys ? Reactivity.mutation(effect, reactivityKeys) : effect;
  })));
  const queryFamily = Atom.family(({
    headers,
    payload,
    reactivityKeys,
    tag,
    timeToLive
  }) => {
    const rpc = options.group.requests.get(tag);
    let atom = RpcSchema.isStreamSchema(rpc.successSchema) ? self.runtime.pull(self.pipe(Effect.map(client => client(tag, payload, {
      headers
    })), Stream.unwrap)) : self.runtime.atom(Effect.flatMap(self, client => client(tag, payload, {
      headers
    })));
    if (timeToLive) {
      atom = Duration.isFinite(timeToLive) ? Atom.setIdleTTL(atom, timeToLive) : Atom.keepAlive(atom);
    }
    return reactivityKeys ? self.runtime.factory.withReactivity(reactivityKeys)(atom) : atom;
  });
  self.query = (tag, payload, options) => queryFamily(new QueryKey({
    tag,
    payload: Data.struct(payload),
    headers: options?.headers ? Data.unsafeStruct(Headers.fromInput(options.headers)) : undefined,
    reactivityKeys: options?.reactivityKeys ? (0, _data.wrapReactivityKeys)(options.reactivityKeys) : undefined,
    timeToLive: options?.timeToLive ? Duration.decode(options.timeToLive) : undefined
  }));
  return self;
};
exports.Tag = Tag;
class QueryKey extends Data.Class {
  [Equal.symbol](that) {
    return this.tag === that.tag && Equal.equals(this.payload, that.payload) && Equal.equals(this.headers, that.headers) && Equal.equals(this.reactivityKeys, that.reactivityKeys) && Equal.equals(this.timeToLive, that.timeToLive);
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.string(this.tag), Hash.combine(Hash.hash(this.payload)), Hash.combine(Hash.hash(this.headers)), Hash.combine(Hash.hash(this.reactivityKeys)), Hash.combine(Hash.hash(this.timeToLive)), Hash.cached(this));
  }
}
//# sourceMappingURL=AtomRpc.js.map