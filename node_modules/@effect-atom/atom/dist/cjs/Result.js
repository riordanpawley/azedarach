"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitingFrom = exports.waiting = exports.value = exports.touch = exports.toExit = exports.success = exports.schemaFromSelf = exports.replacePrevious = exports.matchWithWaiting = exports.matchWithError = exports.match = exports.map = exports.isWaiting = exports.isSuccess = exports.isResult = exports.isNotInitial = exports.isInterrupted = exports.isInitial = exports.isFailure = exports.initial = exports.getOrThrow = exports.getOrElse = exports.fromExitWithPrevious = exports.fromExit = exports.flatMap = exports.failureWithPrevious = exports.failure = exports.failWithPrevious = exports.fail = exports.error = exports.cause = exports.builder = exports.all = exports.TypeId = exports.Schema = void 0;
var Cause = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Cause"));
var Equal = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Equal"));
var Exit = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Exit"));
var _Function = /*#__PURE__*/require("effect/Function");
var Hash = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Hash"));
var Option = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Option"));
var _Pipeable = /*#__PURE__*/require("effect/Pipeable");
var _Predicate = /*#__PURE__*/require("effect/Predicate");
var Schema_ = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Schema"));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
/**
 * @since 1.0.0
 */
/* eslint-disable @typescript-eslint/no-empty-object-type */

/**
 * @since 1.0.0
 * @category type ids
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect-atom/atom/Result");
/**
 * @since 1.0.0
 * @category Guards
 */
const isResult = u => (0, _Predicate.hasProperty)(u, TypeId);
exports.isResult = isResult;
const ResultProto = {
  [TypeId]: {
    E: _Function.identity,
    A: _Function.identity
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  [Equal.symbol](that) {
    if (this._tag !== that._tag || this.waiting !== that.waiting) {
      return false;
    }
    switch (this._tag) {
      case "Initial":
        return true;
      case "Success":
        return Equal.equals(this.value, that.value);
      case "Failure":
        return Equal.equals(this.cause, that.cause);
    }
  },
  [Hash.symbol]() {
    const tagHash = Hash.string(`${this._tag}:${this.waiting}`);
    if (this._tag === "Initial") {
      return Hash.cached(this, tagHash);
    }
    return Hash.cached(this, Hash.combine(tagHash)(this._tag === "Success" ? Hash.hash(this.value) : Hash.hash(this.cause)));
  }
};
/**
 * @since 1.0.0
 * @category refinements
 */
const isWaiting = result => result.waiting;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.isWaiting = isWaiting;
const fromExit = exit => exit._tag === "Success" ? success(exit.value) : failure(exit.cause);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.fromExit = fromExit;
const fromExitWithPrevious = (exit, previous) => exit._tag === "Success" ? success(exit.value) : failureWithPrevious(exit.cause, {
  previous
});
/**
 * @since 1.0.0
 * @category constructors
 */
exports.fromExitWithPrevious = fromExitWithPrevious;
const waitingFrom = previous => {
  if (previous._tag === "None") {
    return initial(true);
  }
  return waiting(previous.value);
};
/**
 * @since 1.0.0
 * @category refinements
 */
exports.waitingFrom = waitingFrom;
const isInitial = result => result._tag === "Initial";
/**
 * @since 1.0.0
 * @category refinements
 */
exports.isInitial = isInitial;
const isNotInitial = result => result._tag !== "Initial";
/**
 * @since 1.0.0
 * @category constructors
 */
exports.isNotInitial = isNotInitial;
const initial = (waiting = false) => {
  const result = Object.create(ResultProto);
  result._tag = "Initial";
  result.waiting = waiting;
  return result;
};
/**
 * @since 1.0.0
 * @category refinements
 */
exports.initial = initial;
const isSuccess = result => result._tag === "Success";
/**
 * @since 1.0.0
 * @category constructors
 */
exports.isSuccess = isSuccess;
const success = (value, options) => {
  const result = Object.create(ResultProto);
  result._tag = "Success";
  result.value = value;
  result.waiting = options?.waiting ?? false;
  result.timestamp = options?.timestamp ?? Date.now();
  return result;
};
/**
 * @since 1.0.0
 * @category refinements
 */
exports.success = success;
const isFailure = result => result._tag === "Failure";
/**
 * @since 1.0.0
 * @category refinements
 */
exports.isFailure = isFailure;
const isInterrupted = result => result._tag === "Failure" && Cause.isInterruptedOnly(result.cause);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.isInterrupted = isInterrupted;
const failure = (cause, options) => {
  const result = Object.create(ResultProto);
  result._tag = "Failure";
  result.cause = cause;
  result.previousSuccess = options?.previousSuccess ?? Option.none();
  result.waiting = options?.waiting ?? false;
  return result;
};
/**
 * @since 1.0.0
 * @category constructors
 */
exports.failure = failure;
const failureWithPrevious = (cause, options) => failure(cause, {
  previousSuccess: Option.flatMap(options.previous, result => isSuccess(result) ? Option.some(result) : isFailure(result) ? result.previousSuccess : Option.none()),
  waiting: options.waiting
});
/**
 * @since 1.0.0
 * @category constructors
 */
exports.failureWithPrevious = failureWithPrevious;
const fail = (error, options) => failure(Cause.fail(error), options);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.fail = fail;
const failWithPrevious = (error, options) => failureWithPrevious(Cause.fail(error), options);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.failWithPrevious = failWithPrevious;
const waiting = (self, options) => {
  if (self.waiting) {
    return options?.touch ? touch(self) : self;
  }
  const result = Object.assign(Object.create(ResultProto), self);
  result.waiting = true;
  if (options?.touch && isSuccess(result)) {
    ;
    result.timestamp = Date.now();
  }
  return result;
};
/**
 * @since 1.0.0
 * @category combinators
 */
exports.waiting = waiting;
const touch = result => {
  if (isSuccess(result)) {
    return success(result.value, {
      waiting: result.waiting
    });
  }
  return result;
};
/**
 * @since 1.0.0
 * @category constructors
 */
exports.touch = touch;
const replacePrevious = (self, previous) => {
  if (self._tag === "Failure") {
    return failureWithPrevious(self.cause, {
      previous,
      waiting: self.waiting
    });
  }
  return self;
};
/**
 * @since 1.0.0
 * @category accessors
 */
exports.replacePrevious = replacePrevious;
const value = self => {
  if (self._tag === "Success") {
    return Option.some(self.value);
  } else if (self._tag === "Failure") {
    return Option.map(self.previousSuccess, s => s.value);
  }
  return Option.none();
};
/**
 * @since 1.0.0
 * @category accessors
 */
exports.value = value;
const getOrElse = exports.getOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, orElse) => Option.getOrElse(value(self), orElse));
/**
 * @since 1.0.0
 * @category accessors
 */
const getOrThrow = self => Option.getOrThrowWith(value(self), () => new Cause.NoSuchElementException("Result.getOrThrow: no value found"));
/**
 * @since 1.0.0
 * @category accessors
 */
exports.getOrThrow = getOrThrow;
const cause = self => self._tag === "Failure" ? Option.some(self.cause) : Option.none();
/**
 * @since 1.0.0
 * @category accessors
 */
exports.cause = cause;
const error = self => self._tag === "Failure" ? Cause.failureOption(self.cause) : Option.none();
/**
 * @since 1.0.0
 * @category combinators
 */
exports.error = error;
const toExit = self => {
  switch (self._tag) {
    case "Success":
      {
        return Exit.succeed(self.value);
      }
    case "Failure":
      {
        return Exit.failCause(self.cause);
      }
    default:
      {
        return Exit.fail(new Cause.NoSuchElementException());
      }
  }
};
/**
 * @since 1.0.0
 * @category combinators
 */
exports.toExit = toExit;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  switch (self._tag) {
    case "Initial":
      return self;
    case "Failure":
      return failure(self.cause, {
        previousSuccess: Option.map(self.previousSuccess, s => success(f(s.value), s)),
        waiting: self.waiting
      });
    case "Success":
      return success(f(self.value), self);
  }
});
/**
 * @since 1.0.0
 * @category combinators
 */
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  switch (self._tag) {
    case "Initial":
      return self;
    case "Failure":
      return failure(self.cause, {
        previousSuccess: Option.flatMap(self.previousSuccess, s => {
          const next = f(s.value, s);
          return isSuccess(next) ? Option.some(next) : Option.none();
        }),
        waiting: self.waiting
      });
    case "Success":
      return f(self.value, self);
  }
});
/**
 * @since 1.0.0
 * @category combinators
 */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  switch (self._tag) {
    case "Initial":
      return options.onInitial(self);
    case "Failure":
      return options.onFailure(self);
    case "Success":
      return options.onSuccess(self);
  }
});
/**
 * @since 1.0.0
 * @category combinators
 */
const matchWithError = exports.matchWithError = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  switch (self._tag) {
    case "Initial":
      return options.onInitial(self);
    case "Failure":
      {
        const e = Cause.failureOrCause(self.cause);
        if (e._tag === "Right") {
          return options.onDefect(Cause.squash(e.right), self);
        }
        return options.onError(e.left, self);
      }
    case "Success":
      return options.onSuccess(self);
  }
});
/**
 * @since 1.0.0
 * @category combinators
 */
const matchWithWaiting = exports.matchWithWaiting = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  if (self.waiting) {
    return options.onWaiting(self);
  }
  switch (self._tag) {
    case "Initial":
      return options.onWaiting(self);
    case "Failure":
      {
        const e = Cause.failureOrCause(self.cause);
        if (e._tag === "Right") {
          return options.onDefect(Cause.squash(e.right), self);
        }
        return options.onError(e.left, self);
      }
    case "Success":
      return options.onSuccess(self);
  }
});
/**
 * Combines multiple results into a single result. Also works with non-result
 * values.
 *
 * @since 1.0.0
 * @category combinators
 */
const all = results => {
  const isIter = (0, _Predicate.isIterable)(results);
  const entries = isIter ? Array.from(results, (result, i) => [i, result]) : Object.entries(results);
  const successes = isIter ? [] : {};
  let waiting = false;
  for (let i = 0; i < entries.length; i++) {
    const [key, result] = entries[i];
    if (!isResult(result)) {
      successes[key] = result;
      continue;
    } else if (!isSuccess(result)) {
      return result;
    }
    successes[key] = result.value;
    if (result.waiting) {
      waiting = true;
    }
  }
  return success(successes, {
    waiting
  });
};
/**
 * @since 1.0.0
 * @category Builder
 */
exports.all = all;
const builder = self => new BuilderImpl(self);
exports.builder = builder;
class BuilderImpl {
  result;
  constructor(result) {
    this.result = result;
  }
  output = /*#__PURE__*/Option.none();
  when(refinement, f) {
    if (Option.isNone(this.output) && refinement(this.result)) {
      const b = f(this.result);
      if (Option.isSome(b)) {
        ;
        this.output = b;
      }
    }
    return this;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  onWaiting(f) {
    return this.when(r => r.waiting, r => Option.some(f(r)));
  }
  onInitialOrWaiting(f) {
    return this.when(r => isInitial(r) || r.waiting, r => Option.some(f(r)));
  }
  onInitial(f) {
    return this.when(isInitial, r => Option.some(f(r)));
  }
  onSuccess(f) {
    return this.when(isSuccess, r => Option.some(f(r.value, r)));
  }
  onFailure(f) {
    return this.when(isFailure, r => Option.some(f(r.cause, r)));
  }
  onError(f) {
    return this.onErrorIf(_Function.constTrue, f);
  }
  onErrorIf(refinement, f) {
    return this.when(isFailure, result => Cause.failureOption(result.cause).pipe(Option.filter(refinement), Option.map(error => f(error, result))));
  }
  onErrorTag(tag, f) {
    return this.onErrorIf(e => (0, _Predicate.hasProperty)(e, "_tag") && (Array.isArray(tag) ? tag.includes(e._tag) : e._tag === tag), f);
  }
  onDefect(f) {
    return this.when(isFailure, result => Cause.dieOption(result.cause).pipe(Option.map(defect => f(defect, result))));
  }
  orElse(orElse) {
    return Option.getOrElse(this.output, orElse);
  }
  orNull() {
    return Option.getOrNull(this.output);
  }
  render() {
    if (Option.isSome(this.output)) {
      return this.output.value;
    } else if (isFailure(this.result)) {
      throw Cause.squash(this.result.cause);
    }
    return null;
  }
}
/**
 * @since 1.0.0
 * @category Schemas
 */
const schemaFromSelf = exports.schemaFromSelf = /*#__PURE__*/Schema_.declare(isResult, {
  identifier: "Result"
});
/**
 * @since 1.0.0
 * @category Schemas
 */
const Schema = options => {
  const success_ = options.success ?? Schema_.Never;
  const error = options.error ?? Schema_.Never;
  const Success = Schema_.TaggedStruct("Success", {
    waiting: Schema_.Boolean,
    timestamp: Schema_.Number,
    value: success_
  });
  return Schema_.transform(Schema_.Union(Schema_.TaggedStruct("Initial", {
    waiting: Schema_.Boolean
  }), Success, Schema_.TaggedStruct("Failure", {
    waiting: Schema_.Boolean,
    previousSuccess: Schema_.Option(Success),
    cause: Schema_.Cause({
      error,
      defect: Schema_.Defect
    })
  })), schemaFromSelf, {
    strict: false,
    decode: e => e._tag === "Initial" ? initial(e.waiting) : e._tag === "Success" ? success(e.value, e) : failure(e.cause, e),
    encode: _Function.identity
  });
};
exports.Schema = Schema;
//# sourceMappingURL=Result.js.map