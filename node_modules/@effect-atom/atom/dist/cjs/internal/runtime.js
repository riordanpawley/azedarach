"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runCallbackSync = void 0;
var _Cause = /*#__PURE__*/require("effect/Cause");
var Exit = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Exit"));
var FiberId = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/FiberId"));
var Runtime = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Runtime"));
var _Scheduler = /*#__PURE__*/require("effect/Scheduler");
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
/**
 * @since 1.0.0
 */

const fastPath = effect => {
  const op = effect;
  switch (op._tag) {
    case "Failure":
    case "Success":
      {
        return op;
      }
    case "Left":
      {
        return Exit.fail(op.left);
      }
    case "Right":
      {
        return Exit.succeed(op.right);
      }
    case "Some":
      {
        return Exit.succeed(op.value);
      }
    case "None":
      {
        // @ts-expect-error
        return Exit.fail(new _Cause.NoSuchElementException());
      }
  }
};
/** @internal */
const runCallbackSync = runtime => {
  const runFork = Runtime.runFork(runtime);
  return (effect, onExit, uninterruptible = false) => {
    const op = fastPath(effect);
    if (op) {
      onExit(op);
      return undefined;
    }
    const scheduler = new _Scheduler.SyncScheduler();
    const fiberRuntime = runFork(effect, {
      scheduler
    });
    scheduler.flush();
    const result = fiberRuntime.unsafePoll();
    if (result) {
      onExit(result);
      return undefined;
    }
    fiberRuntime.addObserver(onExit);
    function cancel() {
      fiberRuntime.removeObserver(onExit);
      if (!uninterruptible) {
        fiberRuntime.unsafeInterruptAsFork(FiberId.none);
      }
    }
    return cancel;
  };
};
exports.runCallbackSync = runCallbackSync;
//# sourceMappingURL=runtime.js.map