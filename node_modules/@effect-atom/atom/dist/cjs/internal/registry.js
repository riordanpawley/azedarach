"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeId = exports.BatchPhase = void 0;
exports.batch = batch;
exports.make = exports.batchState = void 0;
var Effect = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Effect"));
var Equal = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Equal"));
var Exit = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Exit"));
var _Function = /*#__PURE__*/require("effect/Function");
var _GlobalValue = /*#__PURE__*/require("effect/GlobalValue");
var Option = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Option"));
var Queue = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Queue"));
var Stream = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Stream"));
var Result = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("../Result.js"));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
const constImmediate = {
  immediate: true
};
/** @internal */
const TypeId = exports.TypeId = "~effect-atom/atom/Registry";
/** @internal */
const make = options => new RegistryImpl(options?.initialValues, options?.scheduleTask, options?.timeoutResolution, options?.defaultIdleTTL);
exports.make = make;
const SerializableTypeId = "~effect-atom/atom/Atom/Serializable";
const atomKey = atom => SerializableTypeId in atom ? atom[SerializableTypeId].key : atom;
class RegistryImpl {
  scheduleTask;
  defaultIdleTTL;
  [TypeId];
  timeoutResolution;
  constructor(initialValues, scheduleTask = cb => queueMicrotask(cb), timeoutResolution, defaultIdleTTL) {
    this.scheduleTask = scheduleTask;
    this.defaultIdleTTL = defaultIdleTTL;
    this[TypeId] = TypeId;
    if (timeoutResolution === undefined && defaultIdleTTL !== undefined) {
      this.timeoutResolution = Math.round(defaultIdleTTL / 2);
    } else {
      this.timeoutResolution = timeoutResolution ?? 1000;
    }
    if (initialValues !== undefined) {
      for (const [atom, value] of initialValues) {
        this.ensureNode(atom).setValue(value);
      }
    }
  }
  nodes = /*#__PURE__*/new Map();
  preloadedSerializable = /*#__PURE__*/new Map();
  timeoutBuckets = /*#__PURE__*/new Map();
  nodeTimeoutBucket = /*#__PURE__*/new Map();
  disposed = false;
  getNodes() {
    return this.nodes;
  }
  get(atom) {
    return this.ensureNode(atom).value();
  }
  set(atom, value) {
    atom.write(this.ensureNode(atom).writeContext, value);
  }
  setSerializable(key, encoded) {
    this.preloadedSerializable.set(key, encoded);
  }
  modify(atom, f) {
    const node = this.ensureNode(atom);
    const result = f(node.value());
    atom.write(node.writeContext, result[1]);
    return result[0];
  }
  update(atom, f) {
    const node = this.ensureNode(atom);
    atom.write(node.writeContext, f(node.value()));
  }
  refresh = atom => {
    if (atom.refresh !== undefined) {
      atom.refresh(this.refresh);
    } else {
      this.invalidateAtom(atom);
    }
  };
  subscribe(atom, f, options) {
    const node = this.ensureNode(atom);
    if (options?.immediate) {
      f(node.value());
    }
    const remove = node.subscribe(function () {
      f(node._value);
    });
    return () => {
      remove();
      if (node.canBeRemoved) {
        this.scheduleNodeRemoval(node);
      }
    };
  }
  mount(atom) {
    return this.subscribe(atom, _Function.constVoid, constImmediate);
  }
  atomHasTtl(atom) {
    return !atom.keepAlive && atom.idleTTL !== 0 && (atom.idleTTL !== undefined || this.defaultIdleTTL !== undefined);
  }
  ensureNode(atom) {
    const key = atomKey(atom);
    let node = this.nodes.get(key);
    if (node === undefined) {
      node = this.createNode(atom);
      this.nodes.set(key, node);
    } else if (this.atomHasTtl(atom)) {
      this.removeNodeTimeout(node);
    }
    if (typeof key === "string" && this.preloadedSerializable.has(key)) {
      const encoded = this.preloadedSerializable.get(key);
      this.preloadedSerializable.delete(key);
      const decoded = atom[SerializableTypeId].decode(encoded);
      node.setValue(decoded);
    }
    return node;
  }
  createNode(atom) {
    if (this.disposed) {
      throw new Error(`Cannot access Atom ${atom}: registry is disposed`);
    }
    if (!atom.keepAlive) {
      this.scheduleAtomRemoval(atom);
    }
    return new Node(this, atom);
  }
  invalidateAtom = atom => {
    this.ensureNode(atom).invalidate();
  };
  scheduleAtomRemoval(atom) {
    this.scheduleTask(() => {
      const node = this.nodes.get(atomKey(atom));
      if (node !== undefined && node.canBeRemoved) {
        this.removeNode(node);
      }
    });
  }
  scheduleNodeRemoval(node) {
    this.scheduleTask(() => {
      if (node.canBeRemoved) {
        this.removeNode(node);
      }
    });
  }
  removeNode(node) {
    if (this.atomHasTtl(node.atom)) {
      this.setNodeTimeout(node);
    } else {
      this.nodes.delete(atomKey(node.atom));
      node.remove();
    }
  }
  setNodeTimeout(node) {
    if (this.nodeTimeoutBucket.has(node)) {
      return;
    }
    let idleTTL = node.atom.idleTTL ?? this.defaultIdleTTL;
    if (this.#currentSweepTTL !== null) {
      idleTTL -= this.#currentSweepTTL;
      if (idleTTL <= 0) {
        this.nodes.delete(atomKey(node.atom));
        node.remove();
        return;
      }
    }
    const ttl = Math.ceil(idleTTL / this.timeoutResolution) * this.timeoutResolution;
    const timestamp = Date.now() + ttl;
    const bucket = timestamp - timestamp % this.timeoutResolution + this.timeoutResolution;
    let entry = this.timeoutBuckets.get(bucket);
    if (entry === undefined) {
      entry = [new Set(), setTimeout(() => this.sweepBucket(bucket), bucket - Date.now())];
      this.timeoutBuckets.set(bucket, entry);
    }
    entry[0].add(node);
    this.nodeTimeoutBucket.set(node, bucket);
  }
  removeNodeTimeout(node) {
    const bucket = this.nodeTimeoutBucket.get(node);
    if (bucket === undefined) {
      return;
    }
    this.nodeTimeoutBucket.delete(node);
    this.scheduleNodeRemoval(node);
    const [nodes, handle] = this.timeoutBuckets.get(bucket);
    nodes.delete(node);
    if (nodes.size === 0) {
      clearTimeout(handle);
      this.timeoutBuckets.delete(bucket);
    }
  }
  #currentSweepTTL = null;
  sweepBucket(bucket) {
    const nodes = this.timeoutBuckets.get(bucket)[0];
    this.timeoutBuckets.delete(bucket);
    nodes.forEach(node => {
      if (!node.canBeRemoved) {
        return;
      }
      this.nodeTimeoutBucket.delete(node);
      this.nodes.delete(atomKey(node.atom));
      this.#currentSweepTTL = node.atom.idleTTL ?? this.defaultIdleTTL;
      node.remove();
      this.#currentSweepTTL = null;
    });
  }
  reset() {
    this.timeoutBuckets.forEach(([, handle]) => clearTimeout(handle));
    this.timeoutBuckets.clear();
    this.nodeTimeoutBucket.clear();
    this.nodes.forEach(node => node.remove());
    this.nodes.clear();
  }
  dispose() {
    this.disposed = true;
    this.reset();
  }
}
var NodeFlags;
(function (NodeFlags) {
  NodeFlags[NodeFlags["alive"] = 1] = "alive";
  NodeFlags[NodeFlags["initialized"] = 2] = "initialized";
  NodeFlags[NodeFlags["waitingForValue"] = 4] = "waitingForValue";
})(NodeFlags || (NodeFlags = {}));
var NodeState;
(function (NodeState) {
  NodeState[NodeState["uninitialized"] = 5] = "uninitialized";
  NodeState[NodeState["stale"] = 7] = "stale";
  NodeState[NodeState["valid"] = 3] = "valid";
  NodeState[NodeState["removed"] = 0] = "removed";
})(NodeState || (NodeState = {}));
class Node {
  registry;
  atom;
  constructor(registry, atom) {
    this.registry = registry;
    this.atom = atom;
    this.writeContext = new WriteContextImpl(registry, this);
  }
  state = NodeState.uninitialized;
  lifetime;
  writeContext;
  parents = [];
  previousParents;
  children = [];
  listeners = [];
  skipInvalidation = false;
  get canBeRemoved() {
    return !this.atom.keepAlive && this.listeners.length === 0 && this.children.length === 0 && this.state !== 0;
  }
  _value = undefined;
  value() {
    if ((this.state & NodeFlags.waitingForValue) !== 0) {
      this.lifetime = makeLifetime(this);
      const value = this.atom.read(this.lifetime);
      if ((this.state & NodeFlags.waitingForValue) !== 0) {
        this.setValue(value);
      }
      if (this.previousParents) {
        const parents = this.previousParents;
        this.previousParents = undefined;
        for (let i = 0; i < parents.length; i++) {
          parents[i].removeChild(this);
          if (parents[i].canBeRemoved) {
            this.registry.scheduleNodeRemoval(parents[i]);
          }
        }
      }
    }
    return this._value;
  }
  valueOption() {
    if ((this.state & NodeFlags.initialized) === 0) {
      return Option.none();
    }
    return Option.some(this._value);
  }
  setValue(value) {
    if ((this.state & NodeFlags.initialized) === 0) {
      this.state = NodeState.valid;
      this._value = value;
      if (batchState.phase === BatchPhase.collect) {
        batchState.notify.add(this);
      } else {
        this.notify();
      }
      return;
    }
    this.state = NodeState.valid;
    if (Equal.equals(this._value, value)) {
      return;
    }
    this._value = value;
    if (this.skipInvalidation) {
      this.skipInvalidation = false;
    } else {
      this.invalidateChildren();
    }
    if (this.listeners.length > 0) {
      if (batchState.phase === BatchPhase.collect) {
        batchState.notify.add(this);
      } else {
        this.notify();
      }
    }
  }
  addParent(parent) {
    this.parents.push(parent);
    if (this.previousParents !== undefined) {
      const index = this.previousParents.indexOf(parent);
      if (index !== -1) {
        this.previousParents[index] = this.previousParents[this.previousParents.length - 1];
        if (this.previousParents.pop() === undefined) {
          this.previousParents = undefined;
        }
      }
    }
    if (parent.children.indexOf(this) === -1) {
      parent.children.push(this);
      if (parent.skipInvalidation) {
        parent.skipInvalidation = false;
      }
    }
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index !== -1) {
      this.children[index] = this.children[this.children.length - 1];
      this.children.pop();
    }
  }
  invalidate() {
    if (this.state === NodeState.valid) {
      this.state = NodeState.stale;
      this.disposeLifetime();
    }
    if (batchState.phase === BatchPhase.collect) {
      batchState.stale.push(this);
    } else if (this.atom.lazy && this.listeners.length === 0 && !childrenAreActive(this.children)) {
      this.invalidateChildren();
      this.skipInvalidation = true;
    } else {
      this.value();
    }
  }
  invalidateChildren() {
    if (this.children.length === 0) {
      return;
    }
    const children = this.children;
    this.children = [];
    for (let i = 0; i < children.length; i++) {
      children[i].invalidate();
    }
  }
  notify() {
    for (let i = 0; i < this.listeners.length; i++) {
      this.listeners[i]();
    }
    if (batchState.phase === BatchPhase.commit) {
      batchState.notify.delete(this);
    }
  }
  disposeLifetime() {
    if (this.lifetime !== undefined) {
      this.lifetime.dispose();
      this.lifetime = undefined;
    }
    if (this.parents.length !== 0) {
      this.previousParents = this.parents;
      this.parents = [];
    }
  }
  remove() {
    this.state = NodeState.removed;
    this.listeners = [];
    if (this.lifetime === undefined) {
      return;
    }
    this.disposeLifetime();
    if (this.previousParents === undefined) {
      return;
    }
    const parents = this.previousParents;
    this.previousParents = undefined;
    for (let i = 0; i < parents.length; i++) {
      parents[i].removeChild(this);
      if (parents[i].canBeRemoved) {
        this.registry.removeNode(parents[i]);
      }
    }
  }
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index !== -1) {
        this.listeners[index] = this.listeners[this.listeners.length - 1];
        this.listeners.pop();
      }
    };
  }
}
function childrenAreActive(children) {
  if (children.length === 0) {
    return false;
  }
  let current = children;
  let stack;
  let stackIndex = 0;
  while (current !== undefined) {
    for (let i = 0, len = current.length; i < len; i++) {
      const child = current[i];
      if (!child.atom.lazy || child.listeners.length > 0) {
        return true;
      } else if (child.children.length > 0) {
        if (stack === undefined) {
          stack = [child.children];
        } else {
          stack.push(child.children);
        }
      }
    }
    current = stack?.[stackIndex++];
  }
  return false;
}
const disposedError = atom => new Error(`Cannot use context of disposed Atom: ${atom}`);
const LifetimeProto = {
  get registry() {
    return this.node.registry;
  },
  addFinalizer(f) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.finalizers ??= [];
    this.finalizers.push(f);
  },
  get(atom) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    const parent = this.node.registry.ensureNode(atom);
    this.node.addParent(parent);
    return parent.value();
  },
  result(atom, options) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    } else if (this.isFn) {
      return this.resultOnce(atom);
    }
    const result = this.get(atom);
    if (options?.suspendOnWaiting && result.waiting) {
      return Effect.never;
    }
    switch (result._tag) {
      case "Initial":
        {
          return Effect.never;
        }
      case "Failure":
        {
          return Exit.failCause(result.cause);
        }
      case "Success":
        {
          return Effect.succeed(result.value);
        }
    }
  },
  resultOnce(atom, options) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    return Effect.async(resume => {
      const result = this.once(atom);
      if (result._tag !== "Initial" && !(options?.suspendOnWaiting && result.waiting)) {
        return resume(Result.toExit(result));
      }
      const cancel = this.node.registry.subscribe(atom, result => {
        if (result._tag === "Initial" || options?.suspendOnWaiting && result.waiting) return;
        cancel();
        resume(Result.toExit(result));
      }, {
        immediate: false
      });
      return Effect.sync(cancel);
    });
  },
  setResult(atom, value) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.node.registry.set(atom, value);
    return this.resultOnce(atom, {
      suspendOnWaiting: true
    });
  },
  some(atom) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    } else if (this.isFn) {
      return this.someOnce(atom);
    }
    const result = this.get(atom);
    return result._tag === "None" ? Effect.never : Effect.succeed(result.value);
  },
  someOnce(atom) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    return Effect.async(resume => {
      const result = this.once(atom);
      if (Option.isSome(result)) {
        return resume(Effect.succeed(result.value));
      }
      const cancel = this.node.registry.subscribe(atom, result => {
        if (Option.isNone(result)) return;
        cancel();
        resume(Effect.succeed(result.value));
      }, {
        immediate: false
      });
      return Effect.sync(cancel);
    });
  },
  once(atom) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    return this.node.registry.get(atom);
  },
  self() {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    return this.node.valueOption();
  },
  refresh(atom) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.node.registry.refresh(atom);
  },
  refreshSelf() {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.node.invalidate();
  },
  mount(atom) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.addFinalizer(this.node.registry.mount(atom));
  },
  subscribe(atom, f, options) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.addFinalizer(this.node.registry.subscribe(atom, f, options));
  },
  setSelf(a) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.node.setValue(a);
  },
  set(atom, value) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    this.node.registry.set(atom, value);
  },
  stream(atom, options) {
    if (this.disposed) {
      throw disposedError(this.node.atom);
    }
    return (0, _Function.pipe)(Effect.acquireRelease(Queue.bounded(options?.bufferSize ?? 16), Queue.shutdown), Effect.tap(queue => Effect.acquireRelease(Effect.sync(() => {
      return this.node.registry.subscribe(atom, _ => {
        Queue.unsafeOffer(queue, _);
      }, {
        immediate: options?.withoutInitialValue !== true
      });
    }), cancel => Effect.sync(cancel))), Effect.map(queue => Stream.fromQueue(queue)), Stream.unwrapScoped);
  },
  streamResult(atom, options) {
    return (0, _Function.pipe)(this.stream(atom, options), Stream.filter(Result.isNotInitial), Stream.flatMap(result => result._tag === "Success" ? Stream.succeed(result.value) : Stream.failCause(result.cause)));
  },
  dispose() {
    this.disposed = true;
    if (this.finalizers === undefined) {
      return;
    }
    const finalizers = this.finalizers;
    this.finalizers = undefined;
    for (let i = finalizers.length - 1; i >= 0; i--) {
      finalizers[i]();
    }
  }
};
const makeLifetime = node => {
  function get(atom) {
    if (get.disposed) {
      throw disposedError(atom);
    } else if (get.isFn) {
      return node.registry.get(atom);
    }
    const parent = node.registry.ensureNode(atom);
    const value = parent.value();
    node.addParent(parent);
    return value;
  }
  Object.setPrototypeOf(get, LifetimeProto);
  get.isFn = false;
  get.disposed = false;
  get.finalizers = undefined;
  get.node = node;
  return get;
};
class WriteContextImpl {
  registry;
  node;
  constructor(registry, node) {
    this.registry = registry;
    this.node = node;
  }
  get(atom) {
    return this.registry.get(atom);
  }
  set(atom, value) {
    return this.registry.set(atom, value);
  }
  setSelf(value) {
    return this.node.setValue(value);
  }
  refreshSelf() {
    return this.node.invalidate();
  }
}
// -----------------------------------------------------------------------------
// batching
// -----------------------------------------------------------------------------
/** @internal */
var BatchPhase;
(function (BatchPhase) {
  BatchPhase[BatchPhase["disabled"] = 0] = "disabled";
  BatchPhase[BatchPhase["collect"] = 1] = "collect";
  BatchPhase[BatchPhase["commit"] = 2] = "commit";
})(BatchPhase || (exports.BatchPhase = BatchPhase = {}));
/** @internal */
const batchState = exports.batchState = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect-atom/atom/Registry/batchState", () => ({
  phase: BatchPhase.disabled,
  depth: 0,
  stale: [],
  notify: new Set()
}));
/** @internal */
function batch(f) {
  batchState.phase = BatchPhase.collect;
  batchState.depth++;
  try {
    f();
    if (batchState.depth === 1) {
      for (let i = 0; i < batchState.stale.length; i++) {
        batchRebuildNode(batchState.stale[i]);
      }
      batchState.phase = BatchPhase.commit;
      for (const node of batchState.notify) {
        node.notify();
      }
      batchState.notify.clear();
    }
  } finally {
    batchState.depth--;
    if (batchState.depth === 0) {
      batchState.phase = BatchPhase.disabled;
      batchState.stale = [];
    }
  }
}
function batchRebuildNode(node) {
  if (node.state === NodeState.valid) {
    return;
  }
  for (let i = 0; i < node.parents.length; i++) {
    const parent = node.parents[i];
    if (parent.state !== NodeState.valid) {
      batchRebuildNode(parent);
    }
  }
  // @ts-ignore
  if (node.state !== NodeState.valid) {
    node.value();
  }
}
//# sourceMappingURL=registry.js.map