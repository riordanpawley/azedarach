"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toStreamResult = exports.toStream = exports.make = exports.layerOptions = exports.layer = exports.isRegistry = exports.getResult = exports.TypeId = exports.AtomRegistry = void 0;
var Context = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Context"));
var Effect = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Effect"));
var FiberRef = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/FiberRef"));
var _Function = /*#__PURE__*/require("effect/Function");
var Layer = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Layer"));
var Mailbox = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Mailbox"));
var _Predicate = /*#__PURE__*/require("effect/Predicate");
var Scope = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Scope"));
var Stream = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("effect/Stream"));
var internal = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("./internal/registry.js"));
var Result = /*#__PURE__*/_interopRequireWildcard(/*#__PURE__*/require("./Result.js"));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        default: e
      };
    if (null === e || "object" != typeof e && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
    return f;
  })(e, t);
}
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category type ids
 */
const TypeId = exports.TypeId = "~effect-atom/atom/Registry";
/**
 * @since 1.0.0
 * @category guards
 */
const isRegistry = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.isRegistry = isRegistry;
const make = exports.make = internal.make;
/**
 * @since 1.0.0
 * @category Tags
 */
class AtomRegistry extends /*#__PURE__*/Context.Tag("@effect/atom/Registry/CurrentRegistry")() {}
/**
 * @since 1.0.0
 * @category Layers
 */
exports.AtomRegistry = AtomRegistry;
const layerOptions = options => Layer.scoped(AtomRegistry, Effect.gen(function* () {
  const scope = yield* Effect.scope;
  const scheduler = yield* FiberRef.get(FiberRef.currentScheduler);
  const registry = internal.make({
    ...options,
    scheduleTask: options?.scheduleTask ?? (f => scheduler.scheduleTask(f, 0))
  });
  yield* Scope.addFinalizer(scope, Effect.sync(() => registry.dispose()));
  return registry;
}));
/**
 * @since 1.0.0
 * @category Layers
 */
exports.layerOptions = layerOptions;
const layer = exports.layer = /*#__PURE__*/layerOptions();
// -----------------------------------------------------------------------------
// conversions
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category Conversions
 */
const toStream = exports.toStream = /*#__PURE__*/(0, _Function.dual)(2, (self, atom) => Stream.unwrapScoped(Effect.contextWithEffect(context => {
  const scope = Context.get(context, Scope.Scope);
  return Mailbox.make().pipe(Effect.tap(mailbox => {
    const cancel = self.subscribe(atom, value => mailbox.unsafeOffer(value), {
      immediate: true
    });
    return Scope.addFinalizer(scope, Effect.suspend(() => {
      cancel();
      return mailbox.shutdown;
    }));
  }), Effect.uninterruptible, Effect.map(mailbox => Mailbox.toStream(mailbox)));
})));
/**
 * @since 1.0.0
 * @category Conversions
 */
const toStreamResult = exports.toStreamResult = /*#__PURE__*/(0, _Function.dual)(2, (self, atom) => toStream(self, atom).pipe(Stream.filter(Result.isNotInitial), Stream.mapEffect(result => result._tag === "Success" ? Effect.succeed(result.value) : Effect.failCause(result.cause))));
/**
 * @since 1.0.0
 * @category Conversions
 */
const getResult = exports.getResult = /*#__PURE__*/(0, _Function.dual)(args => isRegistry(args[0]), (self, atom, options) => {
  const suspendOnWaiting = options?.suspendOnWaiting ?? false;
  return Effect.async(resume => {
    const result = self.get(atom);
    if (result._tag !== "Initial" && !(suspendOnWaiting && result.waiting)) {
      return resume(Result.toExit(result));
    }
    const cancel = self.subscribe(atom, value => {
      if (value._tag !== "Initial" && !(suspendOnWaiting && value.waiting)) {
        resume(Result.toExit(value));
        cancel();
      }
    });
    return Effect.sync(cancel);
  });
});
//# sourceMappingURL=Registry.js.map