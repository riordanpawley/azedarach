/**
 * @since 1.0.0
 */
import * as Reactivity from "@effect/experimental/Reactivity";
import * as HttpApiClient from "@effect/platform/HttpApiClient";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import { pipe } from "effect/Function";
import * as Hash from "effect/Hash";
import * as Layer from "effect/Layer";
import * as Atom from "./Atom.js";
import { wrapReactivityKeys } from "./internal/data.js";
/**
 * @since 1.0.0
 * @category Constructors
 */
export const Tag = () => (id, options) => {
  const self = Context.Tag(id)();
  self.layer = Layer.scoped(self, HttpApiClient.make(options.api, options)).pipe(Layer.provide(options.httpClient));
  self.runtime = Atom.runtime(self.layer);
  const mutationFamily = Atom.family(({
    endpoint,
    group,
    withResponse
  }) => self.runtime.fn()(Effect.fnUntraced(function* (opts) {
    const client = yield* self;
    const effect = client[group][endpoint]({
      ...opts,
      withResponse
    });
    return yield* opts.reactivityKeys ? Reactivity.mutation(effect, opts.reactivityKeys) : effect;
  })));
  self.mutation = (group, endpoint, options) => mutationFamily(new MutationKey({
    group,
    endpoint,
    withResponse: options?.withResponse ?? false
  }));
  const queryFamily = Atom.family(opts => {
    let atom = self.runtime.atom(Effect.flatMap(self, client_ => {
      const client = client_;
      return client[opts.group][opts.endpoint](opts);
    }));
    if (opts.timeToLive) {
      atom = Duration.isFinite(opts.timeToLive) ? Atom.setIdleTTL(atom, opts.timeToLive) : Atom.keepAlive(atom);
    }
    return opts.reactivityKeys ? self.runtime.factory.withReactivity(opts.reactivityKeys)(atom) : atom;
  });
  self.query = (group, endpoint, request) => queryFamily(new QueryKey({
    group,
    endpoint,
    path: request.path && Data.struct(request.path),
    urlParams: request.urlParams && Data.struct(request.urlParams),
    payload: request.payload && Data.struct(request.payload),
    headers: request.headers && Data.struct(request.headers),
    withResponse: request.withResponse ?? false,
    reactivityKeys: request.reactivityKeys ? wrapReactivityKeys(request.reactivityKeys) : undefined,
    timeToLive: request.timeToLive ? Duration.decode(request.timeToLive) : undefined
  }));
  return self;
};
class MutationKey extends Data.Class {
  [Equal.symbol](that) {
    return this.group === that.group && this.endpoint === that.endpoint && this.withResponse === that.withResponse;
  }
  [Hash.symbol]() {
    return pipe(Hash.string(`${this.group}/${this.endpoint}/${this.withResponse}`), Hash.cached(this));
  }
}
class QueryKey extends Data.Class {
  [Equal.symbol](that) {
    return this.group === that.group && this.endpoint === that.endpoint && Equal.equals(this.path, that.path) && Equal.equals(this.urlParams, that.urlParams) && Equal.equals(this.payload, that.payload) && Equal.equals(this.headers, that.headers) && Equal.equals(this.withResponse, that.withResponse) && Equal.equals(this.reactivityKeys, that.reactivityKeys) && Equal.equals(this.timeToLive, that.timeToLive);
  }
  [Hash.symbol]() {
    return pipe(Hash.string(`${this.group}/${this.endpoint}`), Hash.combine(Hash.hash(this.path)), Hash.combine(Hash.hash(this.urlParams)), Hash.combine(Hash.hash(this.payload)), Hash.combine(Hash.hash(this.headers)), Hash.combine(Hash.hash(this.withResponse)), Hash.combine(Hash.hash(this.reactivityKeys)), Hash.combine(Hash.hash(this.timeToLive)), Hash.cached(this));
  }
}
//# sourceMappingURL=AtomHttpApi.js.map