/**
 * @since 1.0.0
 */
import * as Reactivity from "@effect/experimental/Reactivity";
import * as Headers from "@effect/platform/Headers";
import * as RpcClient from "@effect/rpc/RpcClient";
import * as RpcSchema from "@effect/rpc/RpcSchema";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import { pipe } from "effect/Function";
import * as Hash from "effect/Hash";
import * as Layer from "effect/Layer";
import * as Stream from "effect/Stream";
import * as Atom from "./Atom.js";
import { wrapReactivityKeys } from "./internal/data.js";
/**
 * @since 1.0.0
 * @category Constructors
 */
export const Tag = () => (id, options) => {
  const self = Context.Tag(id)();
  self.layer = Layer.scoped(self, options.makeEffect ?? RpcClient.make(options.group, {
    ...options,
    flatten: true
  })).pipe(Layer.provide(options.protocol));
  self.runtime = Atom.runtime(self.layer);
  self.mutation = Atom.family(tag => self.runtime.fn()(Effect.fnUntraced(function* ({
    headers,
    payload,
    reactivityKeys
  }) {
    const client = yield* self;
    const effect = client(tag, payload, {
      headers
    });
    return yield* reactivityKeys ? Reactivity.mutation(effect, reactivityKeys) : effect;
  })));
  const queryFamily = Atom.family(({
    headers,
    payload,
    reactivityKeys,
    tag,
    timeToLive
  }) => {
    const rpc = options.group.requests.get(tag);
    let atom = RpcSchema.isStreamSchema(rpc.successSchema) ? self.runtime.pull(self.pipe(Effect.map(client => client(tag, payload, {
      headers
    })), Stream.unwrap)) : self.runtime.atom(Effect.flatMap(self, client => client(tag, payload, {
      headers
    })));
    if (timeToLive) {
      atom = Duration.isFinite(timeToLive) ? Atom.setIdleTTL(atom, timeToLive) : Atom.keepAlive(atom);
    }
    return reactivityKeys ? self.runtime.factory.withReactivity(reactivityKeys)(atom) : atom;
  });
  self.query = (tag, payload, options) => queryFamily(new QueryKey({
    tag,
    payload: Data.struct(payload),
    headers: options?.headers ? Data.unsafeStruct(Headers.fromInput(options.headers)) : undefined,
    reactivityKeys: options?.reactivityKeys ? wrapReactivityKeys(options.reactivityKeys) : undefined,
    timeToLive: options?.timeToLive ? Duration.decode(options.timeToLive) : undefined
  }));
  return self;
};
class QueryKey extends Data.Class {
  [Equal.symbol](that) {
    return this.tag === that.tag && Equal.equals(this.payload, that.payload) && Equal.equals(this.headers, that.headers) && Equal.equals(this.reactivityKeys, that.reactivityKeys) && Equal.equals(this.timeToLive, that.timeToLive);
  }
  [Hash.symbol]() {
    return pipe(Hash.string(this.tag), Hash.combine(Hash.hash(this.payload)), Hash.combine(Hash.hash(this.headers)), Hash.combine(Hash.hash(this.reactivityKeys)), Hash.combine(Hash.hash(this.timeToLive)), Hash.cached(this));
  }
}
//# sourceMappingURL=AtomRpc.js.map