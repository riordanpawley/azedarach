/**
 * @since 1.0.0
 */
import { NoSuchElementException } from "effect/Cause";
import * as Exit from "effect/Exit";
import * as FiberId from "effect/FiberId";
import * as Runtime from "effect/Runtime";
import { SyncScheduler } from "effect/Scheduler";
const fastPath = effect => {
  const op = effect;
  switch (op._tag) {
    case "Failure":
    case "Success":
      {
        return op;
      }
    case "Left":
      {
        return Exit.fail(op.left);
      }
    case "Right":
      {
        return Exit.succeed(op.right);
      }
    case "Some":
      {
        return Exit.succeed(op.value);
      }
    case "None":
      {
        // @ts-expect-error
        return Exit.fail(new NoSuchElementException());
      }
  }
};
/** @internal */
export const runCallbackSync = runtime => {
  const runFork = Runtime.runFork(runtime);
  return (effect, onExit, uninterruptible = false) => {
    const op = fastPath(effect);
    if (op) {
      onExit(op);
      return undefined;
    }
    const scheduler = new SyncScheduler();
    const fiberRuntime = runFork(effect, {
      scheduler
    });
    scheduler.flush();
    const result = fiberRuntime.unsafePoll();
    if (result) {
      onExit(result);
      return undefined;
    }
    fiberRuntime.addObserver(onExit);
    function cancel() {
      fiberRuntime.removeObserver(onExit);
      if (!uninterruptible) {
        fiberRuntime.unsafeInterruptAsFork(FiberId.none);
      }
    }
    return cancel;
  };
};
//# sourceMappingURL=runtime.js.map