/**
 * @since 1.0.0
 */
/* eslint-disable @typescript-eslint/no-empty-object-type */
import * as Reactivity from "@effect/experimental/Reactivity";
import * as KeyValueStore from "@effect/platform/KeyValueStore";
import * as Arr from "effect/Array";
import { NoSuchElementException } from "effect/Cause";
import * as Cause from "effect/Cause";
import * as Channel from "effect/Channel";
import * as Chunk from "effect/Chunk";
import * as EffectContext from "effect/Context";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import * as Exit from "effect/Exit";
import * as Fiber from "effect/Fiber";
import * as FiberId from "effect/FiberId";
import * as FiberRef from "effect/FiberRef";
import { constant, constVoid, dual, pipe } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import * as Inspectable from "effect/Inspectable";
import * as Layer from "effect/Layer";
import * as MutableHashMap from "effect/MutableHashMap";
import * as Option from "effect/Option";
import { pipeArguments } from "effect/Pipeable";
import { hasProperty, isObject } from "effect/Predicate";
import * as Runtime from "effect/Runtime";
import * as Schema from "effect/Schema";
import * as Scope from "effect/Scope";
import * as Stream from "effect/Stream";
import * as Subscribable from "effect/Subscribable";
import * as SubscriptionRef from "effect/SubscriptionRef";
import * as internalRegistry from "./internal/registry.js";
import { runCallbackSync } from "./internal/runtime.js";
import * as Registry from "./Registry.js";
import { AtomRegistry } from "./Registry.js";
import * as Result from "./Result.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = "~effect-atom/atom/Atom";
/**
 * @since 1.0.0
 * @category Guards
 */
export const isAtom = u => hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category type ids
 */
export const WritableTypeId = "~effect-atom/atom/Atom/Writable";
/**
 * @since 1.0.0
 * @category combinators
 */
export const setIdleTTL = /*#__PURE__*/dual(2, (self, durationInput) => {
  const duration = Duration.decode(durationInput);
  const isFinite = Duration.isFinite(duration);
  return Object.assign(Object.create(Object.getPrototypeOf(self)), {
    ...self,
    keepAlive: !isFinite,
    idleTTL: isFinite ? Duration.toMillis(duration) : undefined
  });
});
const removeTtl = /*#__PURE__*/setIdleTTL(0);
const AtomProto = {
  [TypeId]: TypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    return {
      _id: "Atom",
      keepAlive: this.keepAlive,
      lazy: this.lazy,
      label: this.label
    };
  },
  toString() {
    return Inspectable.format(this);
  },
  [Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
};
const RuntimeProto = {
  ...AtomProto,
  atom(arg, options) {
    const read = makeRead(arg, options);
    return readable(get => {
      const previous = get.self();
      const runtimeResult = get(this);
      if (runtimeResult._tag !== "Success") {
        return Result.replacePrevious(runtimeResult, previous);
      }
      return read(get, runtimeResult.value);
    });
  },
  fn(arg, options) {
    if (arguments.length === 0) {
      return (arg, options) => makeFnRuntime(this, arg, options);
    }
    return makeFnRuntime(this, arg, options);
  },
  pull(arg, options) {
    const pullSignal = removeTtl(state(0));
    const pullAtom = readable(get => {
      const previous = get.self();
      const runtimeResult = get(this);
      if (runtimeResult._tag !== "Success") {
        return Result.replacePrevious(runtimeResult, previous);
      }
      return makeEffect(get, makeStreamPullEffect(get, pullSignal, arg, options), Result.initial(true), runtimeResult.value);
    });
    return makeStreamPull(pullSignal, pullAtom);
  },
  subscriptionRef(ref) {
    return makeSubRef(removeTtl(readable(get => {
      const previous = get.self();
      const runtimeResult = get(this);
      if (runtimeResult._tag !== "Success") {
        return Result.replacePrevious(runtimeResult, previous);
      }
      const value = typeof ref === "function" ? ref(get) : ref;
      return SubscriptionRef.SubscriptionRefTypeId in value ? value : makeEffect(get, value, Result.initial(true), runtimeResult.value);
    })), (get, ref) => {
      const runtime = Result.getOrThrow(get(this));
      return readSubscribable(get, ref, runtime);
    });
  },
  subscribable(arg) {
    return makeSubscribable(readable(get => {
      const previous = get.self();
      const runtimeResult = get(this);
      if (runtimeResult._tag !== "Success") {
        return Result.replacePrevious(runtimeResult, previous);
      }
      const value = typeof arg === "function" ? arg(get) : arg;
      return Subscribable.isSubscribable(value) ? value : makeEffect(get, value, Result.initial(true), runtimeResult.value);
    }), (get, ref) => {
      const runtime = Result.getOrThrow(get(this));
      return readSubscribable(get, ref, runtime);
    });
  }
};
const makeFnRuntime = (self, arg, options) => {
  const [read, write, argAtom] = makeResultFn(options?.reactivityKeys ? (a, get) => {
    const effect = arg(a, get);
    return Effect.isEffect(effect) ? Reactivity.mutation(effect, options.reactivityKeys) : Stream.ensuring(effect, Reactivity.invalidate(options.reactivityKeys));
  } : arg, options);
  return writable(get => {
    get.get(argAtom);
    const previous = get.self();
    const runtimeResult = get.get(self);
    if (runtimeResult._tag !== "Success") {
      return Result.replacePrevious(runtimeResult, previous);
    }
    return read(get, runtimeResult.value);
  }, write);
};
const WritableProto = {
  ...AtomProto,
  [WritableTypeId]: WritableTypeId
};
/**
 * @since 1.0.0
 * @category refinements
 */
export const isWritable = atom => WritableTypeId in atom;
/**
 * @since 1.0.0
 * @category constructors
 */
export const readable = (read, refresh) => {
  const self = Object.create(AtomProto);
  self.keepAlive = false;
  self.lazy = true;
  self.read = read;
  self.refresh = refresh;
  return self;
};
/**
 * @since 1.0.0
 * @category constructors
 */
export const writable = (read, write, refresh) => {
  const self = Object.create(WritableProto);
  self.keepAlive = false;
  self.lazy = true;
  self.read = read;
  self.write = write;
  self.refresh = refresh;
  return self;
};
function constSetSelf(ctx, value) {
  ctx.setSelf(value);
}
// -----------------------------------------------------------------------------
// constructors
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category constructors
 */
export const make = (arg, options) => {
  const readOrAtom = makeRead(arg, options);
  if (TypeId in readOrAtom) {
    return readOrAtom;
  }
  return readable(readOrAtom);
};
// -----------------------------------------------------------------------------
// constructors - effect
// -----------------------------------------------------------------------------
const isDataType = u => Option.TypeId in u || Either.TypeId in u;
const makeRead = (arg, options) => {
  if (typeof arg === "function" && !Effect.isEffect(arg) && !(Stream.StreamTypeId in arg)) {
    const create = arg;
    return function (get, providedRuntime) {
      const value = create(get);
      if (isObject(value)) {
        if (isDataType(value)) {
          return value;
        } else if (Effect.EffectTypeId in value) {
          return effect(get, value, options, providedRuntime);
        } else if (Stream.StreamTypeId in value) {
          return stream(get, value, options, providedRuntime);
        }
      }
      return value;
    };
  } else if (isObject(arg)) {
    if (isDataType(arg)) {
      return state(arg);
    } else if (Effect.EffectTypeId in arg) {
      return function (get, providedRuntime) {
        return effect(get, arg, options, providedRuntime);
      };
    } else if (Stream.StreamTypeId in arg) {
      return function (get, providedRuntime) {
        return stream(get, arg, options, providedRuntime);
      };
    }
  }
  return state(arg);
};
const state = initialValue => writable(function (_get) {
  return initialValue;
}, constSetSelf);
const effect = (get, effect, options, runtime) => {
  const initialValue = options?.initialValue !== undefined ? Result.success(options.initialValue) : Result.initial();
  return makeEffect(get, effect, initialValue, runtime, options?.uninterruptible);
};
function makeEffect(ctx, effect, initialValue, runtime = Runtime.defaultRuntime, uninterruptible = false) {
  const previous = ctx.self();
  const scope = Effect.runSync(Scope.make());
  ctx.addFinalizer(() => {
    Effect.runFork(Scope.close(scope, Exit.void));
  });
  const contextMap = new Map(runtime.context.unsafeMap);
  contextMap.set(Scope.Scope.key, scope);
  contextMap.set(AtomRegistry.key, ctx.registry);
  const scopedRuntime = Runtime.make({
    context: EffectContext.unsafeMake(contextMap),
    fiberRefs: runtime.fiberRefs,
    runtimeFlags: runtime.runtimeFlags
  });
  let syncResult;
  let isAsync = false;
  const cancel = runCallbackSync(scopedRuntime)(effect, function (exit) {
    syncResult = Result.fromExitWithPrevious(exit, previous);
    if (isAsync) {
      ctx.setSelf(syncResult);
    }
  }, uninterruptible);
  isAsync = true;
  if (cancel !== undefined) {
    ctx.addFinalizer(cancel);
  }
  if (syncResult !== undefined) {
    return syncResult;
  } else if (previous._tag === "Some") {
    return Result.waitingFrom(previous);
  }
  return Result.waiting(initialValue);
}
/**
 * @since 1.0.0
 * @category constructors
 */
export const context = options => {
  let globalLayer = Reactivity.layer;
  function factory(create) {
    const self = Object.create(RuntimeProto);
    self.keepAlive = false;
    self.lazy = true;
    self.refresh = undefined;
    self.factory = factory;
    const layerAtom = keepAlive(typeof create === "function" ? readable(get => Layer.provideMerge(create(get), globalLayer)) : readable(() => Layer.provideMerge(create, globalLayer)));
    self.layer = layerAtom;
    self.read = function read(get) {
      const layer = get(layerAtom);
      const build = Effect.flatMap(Effect.flatMap(Effect.scope, scope => Layer.buildWithMemoMap(layer, options.memoMap, scope)), context => Effect.provide(Effect.runtime(), context));
      return effect(get, build, {
        uninterruptible: true
      });
    };
    return self;
  }
  factory.memoMap = options.memoMap;
  factory.addGlobalLayer = layer => {
    globalLayer = Layer.provideMerge(globalLayer, Layer.provide(layer, Reactivity.layer));
  };
  const reactivityAtom = removeTtl(make(Effect.scopeWith(scope => Layer.buildWithMemoMap(Reactivity.layer, options.memoMap, scope)).pipe(Effect.map(EffectContext.get(Reactivity.Reactivity)))));
  factory.withReactivity = keys => atom => transform(atom, get => {
    const reactivity = Result.getOrThrow(get(reactivityAtom));
    get.addFinalizer(reactivity.unsafeRegister(keys, () => {
      get.refresh(atom);
    }));
    get.subscribe(atom, value => get.setSelf(value));
    return get.once(atom);
  });
  return factory;
};
/**
 * @since 1.0.0
 * @category context
 */
export const defaultMemoMap = /*#__PURE__*/globalValue("@effect-atom/atom/Atom/defaultMemoMap", () => Effect.runSync(Layer.makeMemoMap));
/**
 * @since 1.0.0
 * @category context
 */
export const runtime = /*#__PURE__*/globalValue("@effect-atom/atom/Atom/defaultContext", () => context({
  memoMap: defaultMemoMap
}));
/**
 * An alias to `Rx.runtime.withReactivity`, for refreshing an atom whenever the
 * keys change in the `Reactivity` service.
 *
 * @since 1.0.0
 * @category Reactivity
 */
export const withReactivity = runtime.withReactivity;
// -----------------------------------------------------------------------------
// constructors - stream
// -----------------------------------------------------------------------------
const stream = (get, stream, options, runtime) => {
  const initialValue = options?.initialValue !== undefined ? Result.success(options.initialValue) : Result.initial();
  return makeStream(get, stream, initialValue, runtime);
};
function makeStream(ctx, stream, initialValue, runtime = Runtime.defaultRuntime) {
  const previous = ctx.self();
  const writer = Channel.readWithCause({
    onInput(input) {
      return Channel.suspend(() => {
        const last = Chunk.last(input);
        if (last._tag === "Some") {
          ctx.setSelf(Result.success(last.value, {
            waiting: true
          }));
        }
        return writer;
      });
    },
    onFailure(cause) {
      return Channel.sync(() => {
        ctx.setSelf(Result.failureWithPrevious(cause, {
          previous: ctx.self()
        }));
      });
    },
    onDone(_done) {
      return Channel.sync(() => {
        pipe(ctx.self(), Option.flatMap(Result.value), Option.match({
          onNone: () => ctx.setSelf(Result.failWithPrevious(new NoSuchElementException(), {
            previous: ctx.self()
          })),
          onSome: a => ctx.setSelf(Result.success(a))
        }));
      });
    }
  });
  const registryRuntime = Runtime.make({
    context: EffectContext.add(runtime.context, AtomRegistry, ctx.registry),
    fiberRefs: runtime.fiberRefs,
    runtimeFlags: runtime.runtimeFlags
  });
  const cancel = runCallbackSync(registryRuntime)(Channel.runDrain(Channel.pipeTo(Stream.toChannel(stream), writer)), constVoid, false);
  if (cancel !== undefined) {
    ctx.addFinalizer(cancel);
  }
  if (previous._tag === "Some") {
    return Result.waitingFrom(previous);
  }
  return Result.waiting(initialValue);
}
// -----------------------------------------------------------------------------
// constructors - subscription ref
// -----------------------------------------------------------------------------
/** @internal */
const readSubscribable = (get, sub, runtime = Runtime.defaultRuntime) => {
  if (Subscribable.TypeId in sub) {
    get.addFinalizer(sub.changes.pipe(Stream.runForEach(value => {
      get.setSelf(value);
      return Effect.void;
    }), Runtime.runCallback(runtime)));
    return Runtime.runSync(runtime)(sub.get);
  } else if (sub._tag !== "Success") {
    return sub;
  }
  return makeStream(get, sub.value.changes, Result.initial(true), runtime);
};
const makeSubRef = (refAtom, read) => {
  function write(ctx, value) {
    const ref = ctx.get(refAtom);
    if (SubscriptionRef.SubscriptionRefTypeId in ref) {
      Effect.runSync(SubscriptionRef.set(ref, value));
    } else if (Result.isSuccess(ref)) {
      Effect.runSync(SubscriptionRef.set(ref.value, value));
    }
  }
  return writable(get => {
    const ref = get(refAtom);
    if (SubscriptionRef.SubscriptionRefTypeId in ref) {
      return read(get, ref);
    } else if (Result.isSuccess(ref)) {
      return read(get, ref);
    }
    return ref;
  }, write);
};
/**
 * @since 1.0.0
 * @category constructors
 */
export const subscriptionRef = ref => makeSubRef(readable(get => {
  const value = typeof ref === "function" ? ref(get) : ref;
  return SubscriptionRef.SubscriptionRefTypeId in value ? value : makeEffect(get, value, Result.initial(true));
}), readSubscribable);
// -----------------------------------------------------------------------------
// constructors - subscribable
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category constructors
 */
export const subscribable = ref => makeSubscribable(readable(get => {
  const value = typeof ref === "function" ? ref(get) : ref;
  return Subscribable.isSubscribable(value) ? value : makeEffect(get, value, Result.initial(true));
}), readSubscribable);
const makeSubscribable = (subAtom, read) => readable(get => {
  const sub = get(subAtom);
  if (Subscribable.isSubscribable(sub)) {
    return read(get, sub);
  } else if (Result.isSuccess(sub)) {
    return read(get, sub);
  }
  return sub;
});
/**
 * @since 1.0.0
 * @category constructors
 */
export const fnSync = function (...args) {
  if (args.length === 0) {
    return makeFnSync;
  }
  return makeFnSync(...args);
};
const makeFnSync = (f, options) => {
  const argAtom = removeTtl(state([0, undefined]));
  const hasInitialValue = options?.initialValue !== undefined;
  return writable(function (get) {
    ;
    get.isFn = true;
    const [counter, arg] = get.get(argAtom);
    if (counter === 0) {
      return hasInitialValue ? options.initialValue : Option.none();
    }
    return hasInitialValue ? f(arg, get) : Option.some(f(arg, get));
  }, function (ctx, arg) {
    batch(() => {
      ctx.set(argAtom, [ctx.get(argAtom)[0] + 1, arg]);
      ctx.refreshSelf();
    });
  });
};
/**
 * @since 1.0.0
 * @category symbols
 */
export const Reset = /*#__PURE__*/Symbol.for("@effect-atom/atom/Atom/Reset");
/**
 * @since 1.0.0
 * @category symbols
 */
export const Interrupt = /*#__PURE__*/Symbol.for("@effect-atom/atom/Atom/Interrupt");
/**
 * @since 1.0.0
 * @category constructors
 */
export const fn = function (...args) {
  if (args.length === 0) {
    return makeFn;
  }
  return makeFn(...args);
};
const makeFn = (f, options) => {
  const [read, write] = makeResultFn(f, options);
  return writable(read, write);
};
function makeResultFn(f, options) {
  const argAtom = removeTtl(state([0, undefined]));
  const initialValue = options?.initialValue !== undefined ? Result.success(options.initialValue) : Result.initial();
  const fibersAtom = options?.concurrent ? removeTtl(readable(get => {
    const fibers = new Set();
    get.addFinalizer(() => fibers.forEach(f => f.unsafeInterruptAsFork(FiberId.none)));
    return fibers;
  })) : undefined;
  function read(get, runtime) {
    const fibers = fibersAtom ? get(fibersAtom) : undefined;
    get.isFn = true;
    const [counter, arg] = get.get(argAtom);
    if (counter === 0) {
      return initialValue;
    } else if (arg === Interrupt) {
      return Result.failureWithPrevious(Cause.interrupt(FiberId.none), {
        previous: get.self()
      });
    }
    let value = f(arg, get);
    if (Effect.EffectTypeId in value) {
      if (fibers) {
        const eff = value;
        value = Effect.flatMap(Effect.runtime(), r => {
          const fiber = Runtime.runFork(r, eff);
          fibers.add(fiber);
          const arr = Array.from(fibers);
          fiber.addObserver(() => fibers.delete(fiber));
          return joinAll(arr);
        });
      }
      return makeEffect(get, value, initialValue, runtime, false);
    }
    return makeStream(get, value, initialValue, runtime);
  }
  function write(ctx, arg) {
    batch(() => {
      if (arg === Reset) {
        ctx.set(argAtom, [0, undefined]);
      } else if (arg === Interrupt) {
        ctx.set(argAtom, [ctx.get(argAtom)[0] + 1, Interrupt]);
      } else {
        ctx.set(argAtom, [ctx.get(argAtom)[0] + 1, arg]);
      }
      ctx.refreshSelf();
    });
  }
  return [read, write, argAtom];
}
const joinAll = fibers => Effect.async(resume => {
  let i = 0;
  let cause;
  let exit;
  function onExit(exit_, inLoop = false) {
    if (exit_._tag === "Failure") {
      cause = cause ? Cause.parallel(exit_.cause, cause) : exit_.cause;
    } else if (!cause) {
      exit = exit_;
    }
    i++;
    if (!inLoop) loop();
  }
  function loop() {
    while (i < fibers.length) {
      const fiber = fibers[i];
      const exit = fiber.unsafePoll();
      if (!exit) return fiber.addObserver(onExit);
      onExit(exit, true);
    }
    resume(cause ? Exit.failCause(cause) : exit ? exit : Exit.failCause(Cause.empty));
  }
  loop();
  return Effect.sync(() => {
    if (i < fibers.length) {
      fibers[i].removeObserver(onExit);
    }
  });
});
/**
 * @since 1.0.0
 * @category constructors
 */
export const pull = (create, options) => {
  const pullSignal = removeTtl(state(0));
  const pullAtom = readable(makeRead(function (get) {
    return makeStreamPullEffect(get, pullSignal, create, options);
  }));
  return makeStreamPull(pullSignal, pullAtom);
};
const makeStreamPullEffect = (get, pullSignal, create, options) => Effect.flatMap(Channel.toPull(Stream.toChannel(typeof create === "function" ? create(get) : create)), pullChunk => {
  const semaphore = Effect.unsafeMakeSemaphore(1);
  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
  const context = fiber.currentContext;
  let acc = Chunk.empty();
  const pull = Effect.flatMap(Effect.locally(Effect.suspend(() => pullChunk), FiberRef.currentContext, context), Either.match({
    onLeft: () => {
      const items = Chunk.toReadonlyArray(acc);
      if (!Arr.isNonEmptyArray(items)) {
        return Effect.fail(new Cause.NoSuchElementException(`Atom.pull: no items`));
      }
      return Effect.succeed({
        done: true,
        items
      });
    },
    onRight(chunk) {
      let items;
      if (options?.disableAccumulation) {
        items = chunk;
      } else {
        items = Chunk.appendAll(acc, chunk);
        acc = items;
      }
      const arr = Chunk.toReadonlyArray(items);
      if (!Arr.isNonEmptyArray(arr)) {
        return pull;
      }
      return Effect.succeed({
        done: false,
        items: arr
      });
    }
  }));
  const pullWithSemaphore = semaphore.withPermits(1)(pull);
  const runCallback = runCallbackSync(Runtime.make({
    context,
    fiberRefs: fiber.getFiberRefs(),
    runtimeFlags: Runtime.defaultRuntime.runtimeFlags
  }));
  const cancels = new Set();
  get.addFinalizer(() => {
    for (const cancel of cancels) cancel();
  });
  get.once(pullSignal);
  get.subscribe(pullSignal, () => {
    get.setSelf(Result.waitingFrom(get.self()));
    let cancel;
    // eslint-disable-next-line prefer-const
    cancel = runCallback(pullWithSemaphore, exit => {
      if (cancel) cancels.delete(cancel);
      const result = Result.fromExitWithPrevious(exit, get.self());
      const pending = cancels.size > 0;
      get.setSelf(pending ? Result.waiting(result) : result);
    });
    if (cancel) cancels.add(cancel);
  });
  return pull;
});
const makeStreamPull = (pullSignal, pullAtom) => writable(pullAtom.read, function (ctx, _) {
  ctx.set(pullSignal, ctx.get(pullSignal) + 1);
});
/**
 * @since 1.0.0
 * @category constructors
 */
export const family = typeof WeakRef === "undefined" || typeof FinalizationRegistry === "undefined" ? f => {
  const atoms = MutableHashMap.empty();
  return function (arg) {
    const atomEntry = MutableHashMap.get(atoms, arg);
    if (atomEntry._tag === "Some") {
      return atomEntry.value;
    }
    const newAtom = f(arg);
    MutableHashMap.set(atoms, arg, newAtom);
    return newAtom;
  };
} : f => {
  const atoms = MutableHashMap.empty();
  const registry = new FinalizationRegistry(arg => {
    MutableHashMap.remove(atoms, arg);
  });
  return function (arg) {
    const atomEntry = MutableHashMap.get(atoms, arg).pipe(Option.flatMapNullable(ref => ref.deref()));
    if (atomEntry._tag === "Some") {
      return atomEntry.value;
    }
    const newAtom = f(arg);
    MutableHashMap.set(atoms, arg, new WeakRef(newAtom));
    registry.register(newAtom, arg);
    return newAtom;
  };
};
/**
 * @since 1.0.0
 * @category combinators
 */
export const withFallback = /*#__PURE__*/dual(2, (self, fallback) => {
  function withFallback(get) {
    const result = get(self);
    if (result._tag === "Initial") {
      return Result.waiting(get(fallback));
    }
    return result;
  }
  return isWritable(self) ? writable(withFallback, self.write, self.refresh ?? function (refresh) {
    refresh(self);
  }) : readable(withFallback, self.refresh ?? function (refresh) {
    refresh(self);
  });
});
/**
 * @since 1.0.0
 * @category combinators
 */
export const keepAlive = self => Object.assign(Object.create(Object.getPrototypeOf(self)), {
  ...self,
  keepAlive: true
});
/**
 * Reverts the `keepAlive` behavior of a reactive value, allowing it to be
 * disposed of when not in use.
 *
 * Note that Atom's have this behavior by default.
 *
 * @since 1.0.0
 * @category combinators
 */
export const autoDispose = self => Object.assign(Object.create(Object.getPrototypeOf(self)), {
  ...self,
  keepAlive: false
});
/**
 * @since 1.0.0
 * @category combinators
 */
export const setLazy = /*#__PURE__*/dual(2, (self, lazy) => Object.assign(Object.create(Object.getPrototypeOf(self)), {
  ...self,
  lazy
}));
/**
 * @since 1.0.0
 * @category combinators
 */
export const withLabel = /*#__PURE__*/dual(2, (self, name) => Object.assign(Object.create(Object.getPrototypeOf(self)), {
  ...self,
  label: [name, new Error().stack?.split("\n")[5] ?? ""]
}));
/**
 * @since 1.0.0
 * @category combinators
 */
export const initialValue = /*#__PURE__*/dual(2, (self, initialValue) => [self, initialValue]);
/**
 * @since 1.0.0
 * @category combinators
 */
export const transform = /*#__PURE__*/dual(2, (self, f) => isWritable(self) ? writable(f, function (ctx, value) {
  ctx.set(self, value);
}, self.refresh ?? function (refresh) {
  refresh(self);
}) : readable(f, self.refresh ?? function (refresh) {
  refresh(self);
}));
/**
 * @since 1.0.0
 * @category combinators
 */
export const map = /*#__PURE__*/dual(2, (self, f) => transform(self, get => f(get(self))));
/**
 * @since 1.0.0
 * @category combinators
 */
export const mapResult = /*#__PURE__*/dual(2, (self, f) => map(self, Result.map(f)));
/**
 * @since 1.0.0
 * @category combinators
 */
export const debounce = /*#__PURE__*/dual(2, (self, duration) => {
  const millis = Duration.toMillis(duration);
  return transform(self, function (get) {
    let timeout;
    let value = get.once(self);
    function update() {
      timeout = undefined;
      get.setSelf(value);
    }
    get.addFinalizer(function () {
      if (timeout) clearTimeout(timeout);
    });
    get.subscribe(self, function (val) {
      value = val;
      if (timeout) clearTimeout(timeout);
      timeout = setTimeout(update, millis);
    });
    return value;
  });
});
/**
 * @since 1.0.0
 * @category Optimistic
 */
export const optimistic = self => {
  let counter = 0;
  const writeAtom = removeTtl(state([counter, undefined]));
  return writable(get => {
    let lastValue = get.once(self);
    let needsRefresh = false;
    get.subscribe(self, value => {
      lastValue = value;
      if (transitions.size > 0) {
        return;
      }
      needsRefresh = false;
      if (!Result.isResult(value)) {
        return get.setSelf(value);
      }
      const current = Option.getOrUndefined(get.self());
      switch (value._tag) {
        case "Initial":
          {
            if (Result.isInitial(current)) {
              get.setSelf(value);
            }
            return;
          }
        case "Success":
          {
            if (Result.isSuccess(current)) {
              if (!value.waiting && value.timestamp >= current.timestamp) {
                get.setSelf(value);
              }
            } else {
              get.setSelf(value);
            }
            return;
          }
        case "Failure":
          {
            return get.setSelf(value);
          }
      }
    });
    const transitions = new Set();
    const cancels = new Set();
    get.subscribe(writeAtom, ([, atom]) => {
      if (transitions.has(atom)) return;
      transitions.add(atom);
      let cancel;
      // eslint-disable-next-line prefer-const
      cancel = get.registry.subscribe(atom, result => {
        if (Result.isSuccess(result) && result.waiting) {
          return get.setSelf(result.value);
        }
        transitions.delete(atom);
        if (cancel) {
          cancels.delete(cancel);
          cancel();
        }
        if (!needsRefresh && !Result.isFailure(result)) {
          needsRefresh = true;
        }
        if (transitions.size === 0) {
          if (needsRefresh) {
            needsRefresh = false;
            get.refresh(self);
          } else {
            get.setSelf(lastValue);
          }
        }
      }, {
        immediate: true
      });
      if (transitions.has(atom)) {
        cancels.add(cancel);
      } else {
        cancel();
      }
    });
    get.addFinalizer(() => {
      for (const cancel of cancels) cancel();
      transitions.clear();
      cancels.clear();
    });
    return lastValue;
  }, (ctx, atom) => ctx.set(writeAtom, [++counter, atom]), refresh => refresh(self));
};
/**
 * @since 1.0.0
 * @category Optimistic
 */
export const optimisticFn = /*#__PURE__*/dual(2, (self, options) => {
  const transition = removeTtl(state(Result.initial()));
  return fn((arg, get) => {
    let value = options.reducer(get(self), arg);
    if (Result.isResult(value)) {
      value = Result.waiting(value, {
        touch: true
      });
    }
    get.set(transition, Result.success(value, {
      waiting: true
    }));
    get.set(self, transition);
    const fn = typeof options.fn === "function" ? autoDispose(options.fn(value => get.set(transition, Result.success(Result.isResult(value) ? Result.waiting(value) : value, {
      waiting: true
    })))) : options.fn;
    get.set(fn, arg);
    return Effect.async(resume => {
      get.subscribe(fn, result => {
        if (result._tag === "Initial" || result.waiting) return;
        get.set(transition, Result.map(result, () => value));
        resume(Result.toExit(result));
      }, {
        immediate: true
      });
    });
  });
});
/**
 * @since 1.0.0
 * @category batching
 */
export const batch = internalRegistry.batch;
// -----------------------------------------------------------------------------
// Focus
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category Focus
 */
export const windowFocusSignal = /*#__PURE__*/readable(get => {
  let count = 0;
  function update() {
    if (document.visibilityState === "visible") {
      get.setSelf(++count);
    }
  }
  window.addEventListener("visibilitychange", update);
  get.addFinalizer(() => {
    window.removeEventListener("visibilitychange", update);
  });
  return count;
});
/**
 * @since 1.0.0
 * @category Focus
 */
export const makeRefreshOnSignal = signal => self => transform(self, get => {
  get.once(signal);
  get.subscribe(signal, _ => get.refresh(self));
  get.subscribe(self, value => get.setSelf(value));
  return get.once(self);
});
/**
 * @since 1.0.0
 * @category Focus
 */
export const refreshOnWindowFocus = /*#__PURE__*/makeRefreshOnSignal(windowFocusSignal);
// -----------------------------------------------------------------------------
// KeyValueStore
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category KeyValueStore
 */
export const kvs = options => {
  const setAtom = options.runtime.fn(Effect.fnUntraced(function* (value) {
    const store = (yield* KeyValueStore.KeyValueStore).forSchema(options.schema);
    yield* store.set(options.key, value);
  }));
  const resultAtom = options.runtime.atom(Effect.flatMap(KeyValueStore.KeyValueStore, store => Effect.flatten(store.forSchema(options.schema).get(options.key))));
  return writable(get => {
    get.mount(setAtom);
    return Result.getOrElse(get(resultAtom), options.defaultValue);
  }, (ctx, value) => {
    ctx.set(setAtom, value);
    ctx.setSelf(value);
  });
};
// -----------------------------------------------------------------------------
// URL search params
// -----------------------------------------------------------------------------
/**
 * Create an Atom that reads and writes a URL search parameter.
 *
 * Note: If you pass a schema, it has to be synchronous and have no context.
 *
 * @since 1.0.0
 * @category URL search params
 */
export const searchParam = (name, options) => {
  const decode = options?.schema && Schema.decodeEither(options.schema);
  const encode = options?.schema && Schema.encodeEither(options.schema);
  return writable(get => {
    if (typeof window === "undefined") {
      return decode ? Option.none() : "";
    }
    const handleUpdate = () => {
      if (searchParamState.updating) return;
      const searchParams = new URLSearchParams(window.location.search);
      const newValue = searchParams.get(name) || "";
      if (decode) {
        get.setSelf(Either.getRight(decode(newValue)));
      } else if (newValue !== Option.getOrUndefined(get.self())) {
        get.setSelf(newValue);
      }
    };
    window.addEventListener("popstate", handleUpdate);
    window.addEventListener("pushstate", handleUpdate);
    get.addFinalizer(() => {
      window.removeEventListener("popstate", handleUpdate);
      window.removeEventListener("pushstate", handleUpdate);
    });
    const value = new URLSearchParams(window.location.search).get(name) || "";
    return decode ? Either.getRight(decode(value)) : value;
  }, (ctx, value) => {
    if (typeof window === "undefined") {
      ctx.setSelf(value);
      return;
    }
    if (encode) {
      const encoded = Option.flatMap(value, v => Either.getRight(encode(v)));
      searchParamState.updates.set(name, Option.getOrElse(encoded, () => ""));
      value = Option.zipRight(encoded, value);
    } else {
      searchParamState.updates.set(name, value);
    }
    ctx.setSelf(value);
    if (searchParamState.timeout) {
      clearTimeout(searchParamState.timeout);
    }
    searchParamState.timeout = setTimeout(updateSearchParams, 500);
  });
};
const searchParamState = {
  timeout: undefined,
  updates: /*#__PURE__*/new Map(),
  updating: false
};
function updateSearchParams() {
  searchParamState.timeout = undefined;
  searchParamState.updating = true;
  const searchParams = new URLSearchParams(window.location.search);
  for (const [key, value] of searchParamState.updates.entries()) {
    if (value.length > 0) {
      searchParams.set(key, value);
    } else {
      searchParams.delete(key);
    }
  }
  searchParamState.updates.clear();
  const newUrl = `${window.location.pathname}?${searchParams.toString()}`;
  window.history.pushState({}, "", newUrl);
  searchParamState.updating = false;
}
// -----------------------------------------------------------------------------
// conversions
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category Conversions
 */
export const toStream = self => Stream.unwrap(Effect.map(AtomRegistry, Registry.toStream(self)));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const toStreamResult = self => Stream.unwrap(Effect.map(AtomRegistry, Registry.toStreamResult(self)));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const get = self => Effect.map(AtomRegistry, _ => _.get(self));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const modify = /*#__PURE__*/dual(2, (self, f) => Effect.map(AtomRegistry, _ => _.modify(self, f)));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const set = /*#__PURE__*/dual(2, (self, value) => Effect.map(AtomRegistry, _ => _.set(self, value)));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const update = /*#__PURE__*/dual(2, (self, f) => Effect.map(AtomRegistry, _ => _.update(self, f)));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const getResult = (self, options) => Effect.flatMap(AtomRegistry, Registry.getResult(self, options));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const refresh = self => Effect.map(AtomRegistry, _ => _.refresh(self));
// -----------------------------------------------------------------------------
// Serializable
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category Serializable
 */
export const SerializableTypeId = "~effect-atom/atom/Atom/Serializable";
/**
 * @since 1.0.0
 * @category Serializable
 */
export const isSerializable = self => SerializableTypeId in self;
/**
 * @since 1.0.0
 * @category combinators
 */
export const serializable = /*#__PURE__*/dual(2, (self, options) => Object.assign(Object.create(Object.getPrototypeOf(self)), {
  ...self,
  label: self.label ?? [options.key, new Error().stack?.split("\n")[5] ?? ""],
  [SerializableTypeId]: {
    key: options.key,
    encode: Schema.encodeSync(options.schema),
    decode: Schema.decodeSync(options.schema)
  }
}));
/**
 * @since 1.0.0
 * @category ServerValue
 */
export const ServerValueTypeId = "~effect-atom/atom/Atom/ServerValue";
/**
 * Overrides the value of an Atom when read on the server.
 *
 * @since 1.0.0
 * @category ServerValue
 */
export const withServerValue = /*#__PURE__*/dual(2, (self, read) => Object.assign(Object.create(Object.getPrototypeOf(self)), {
  ...self,
  [ServerValueTypeId]: read
}));
/**
 * Sets the Atom's server value to `Result.initial(true)`.
 *
 * @since 1.0.0
 * @category ServerValue
 */
export const withServerValueInitial = self => withServerValue(self, constant(Result.initial(true)));
/**
 * @since 1.0.0
 * @category ServerValue
 */
export const getServerValue = /*#__PURE__*/dual(2, (self, registry) => ServerValueTypeId in self ? self[ServerValueTypeId](atom => registry.get(atom)) : registry.get(self));
//# sourceMappingURL=Atom.js.map