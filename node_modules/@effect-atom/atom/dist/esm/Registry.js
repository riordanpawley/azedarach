/**
 * @since 1.0.0
 */
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as FiberRef from "effect/FiberRef";
import { dual } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import { hasProperty } from "effect/Predicate";
import * as Scope from "effect/Scope";
import * as Stream from "effect/Stream";
import * as internal from "./internal/registry.js";
import * as Result from "./Result.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = "~effect-atom/atom/Registry";
/**
 * @since 1.0.0
 * @category guards
 */
export const isRegistry = u => hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category constructors
 */
export const make = internal.make;
/**
 * @since 1.0.0
 * @category Tags
 */
export class AtomRegistry extends /*#__PURE__*/Context.Tag("@effect/atom/Registry/CurrentRegistry")() {}
/**
 * @since 1.0.0
 * @category Layers
 */
export const layerOptions = options => Layer.scoped(AtomRegistry, Effect.gen(function* () {
  const scope = yield* Effect.scope;
  const scheduler = yield* FiberRef.get(FiberRef.currentScheduler);
  const registry = internal.make({
    ...options,
    scheduleTask: options?.scheduleTask ?? (f => scheduler.scheduleTask(f, 0))
  });
  yield* Scope.addFinalizer(scope, Effect.sync(() => registry.dispose()));
  return registry;
}));
/**
 * @since 1.0.0
 * @category Layers
 */
export const layer = /*#__PURE__*/layerOptions();
// -----------------------------------------------------------------------------
// conversions
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category Conversions
 */
export const toStream = /*#__PURE__*/dual(2, (self, atom) => Stream.unwrapScoped(Effect.contextWithEffect(context => {
  const scope = Context.get(context, Scope.Scope);
  return Mailbox.make().pipe(Effect.tap(mailbox => {
    const cancel = self.subscribe(atom, value => mailbox.unsafeOffer(value), {
      immediate: true
    });
    return Scope.addFinalizer(scope, Effect.suspend(() => {
      cancel();
      return mailbox.shutdown;
    }));
  }), Effect.uninterruptible, Effect.map(mailbox => Mailbox.toStream(mailbox)));
})));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const toStreamResult = /*#__PURE__*/dual(2, (self, atom) => toStream(self, atom).pipe(Stream.filter(Result.isNotInitial), Stream.mapEffect(result => result._tag === "Success" ? Effect.succeed(result.value) : Effect.failCause(result.cause))));
/**
 * @since 1.0.0
 * @category Conversions
 */
export const getResult = /*#__PURE__*/dual(args => isRegistry(args[0]), (self, atom, options) => {
  const suspendOnWaiting = options?.suspendOnWaiting ?? false;
  return Effect.async(resume => {
    const result = self.get(atom);
    if (result._tag !== "Initial" && !(suspendOnWaiting && result.waiting)) {
      return resume(Result.toExit(result));
    }
    const cancel = self.subscribe(atom, value => {
      if (value._tag !== "Initial" && !(suspendOnWaiting && value.waiting)) {
        resume(Result.toExit(value));
        cancel();
      }
    });
    return Effect.sync(cancel);
  });
});
//# sourceMappingURL=Registry.js.map